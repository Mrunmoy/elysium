"""
Embedded C++ code emitter: generates server and client source files
targeting the ms-os kernel IPC API (messageSend/Receive/Reply).

Each service produces up to five files:
  {Name}Types.h      -- enums, POD structs (only if enums/structs defined)
  {Name}Server.h     -- server class with pure virtual handlers + run()
  {Name}Server.cpp   -- dispatch loop: receive -> switch -> handle -> reply
  {Name}Client.h     -- client class with typed RPC stubs
  {Name}Client.cpp   -- stubs: marshal -> messageSend -> unmarshal reply
"""

from typing import Optional

from .parser import IdlFile, Method, Notification
from .types import TYPE_MAP, cpp_type, fnv1a_32


def _resolve_type(idl_type: str, idl: IdlFile) -> str:
    """Map IDL type to C++. Built-ins go through TYPE_MAP; user types pass through."""
    if idl_type in TYPE_MAP:
        return cpp_type(idl_type)
    return idl_type


def _param_decl(p, idl: IdlFile, is_out: bool = False) -> str:
    """Full C++ parameter declaration for a method param."""
    if p.type_name == "string":
        return f"char *{p.name}" if is_out else f"const char *{p.name}"
    base = _resolve_type(p.type_name, idl)
    if p.array_size is not None:
        if is_out:
            return f"{base} *{p.name}"
        return f"const {base} *{p.name}"
    if is_out:
        return f"{base} *{p.name}"
    return f"{base} {p.name}"


def _wire_size(p, idl: IdlFile) -> str:
    """Byte-size expression for a param's wire representation."""
    if p.type_name == "string":
        return str(p.array_size + 1)
    base = _resolve_type(p.type_name, idl)
    if p.array_size is not None:
        return f"{p.array_size} * sizeof({base})"
    return f"sizeof({base})"


def _total_wire_size_parts(params, idl: IdlFile):
    """List of C++ size expressions for a list of params."""
    return [_wire_size(p, idl) for p in params]


# -- Types header ----------------------------------------------------------

def emit_types_h(idl: IdlFile) -> str:
    """Generate a shared types header with enum and struct definitions."""
    name = idl.service_name
    lines = []
    w = lines.append

    w("// Auto-generated by ipcgen (embedded) -- do not edit.")
    w("#pragma once")
    w("")
    w("#include <cstdint>")
    w("")
    w("namespace kernel")
    w("{")
    w("namespace ipc")
    w("{")

    for enum_def in idl.enums:
        w("")
        w(f"enum {enum_def.name} : std::uint32_t")
        w("{")
        for val in enum_def.values:
            w(f"    {val.name} = {val.value},")
        w("};")

    for struct_def in idl.structs:
        w("")
        w(f"struct {struct_def.name}")
        w("{")
        for f in struct_def.fields:
            if f.type_name == "string":
                w(f"    char {f.name}[{f.array_size + 1}];")
            else:
                base = _resolve_type(f.type_name, idl)
                if f.array_size is not None:
                    w(f"    {base} {f.name}[{f.array_size}];")
                else:
                    w(f"    {base} {f.name};")
        w("};")

    w("")
    w("}  // namespace ipc")
    w("}  // namespace kernel")
    w("")

    return "\n".join(lines)


# -- Server header ----------------------------------------------------------

def emit_server_h(idl: IdlFile) -> str:
    name = idl.service_name
    service_id = fnv1a_32(name)
    lines = []
    w = lines.append

    w("// Auto-generated by ipcgen (embedded) -- do not edit.")
    w("#pragma once")
    w("")
    w('#include "kernel/Ipc.h"')
    if idl.enums or idl.structs:
        w(f'#include "{name}Types.h"')
    w("")
    w("#include <cstdint>")
    w("#include <cstring>")
    w("")
    w("namespace kernel")
    w("{")
    w("namespace ipc")
    w("{")
    w("")
    w(f"class {name}Server")
    w("{")
    w("public:")
    w(f"    static constexpr std::uint32_t kServiceId = 0x{service_id:08x}u;")
    w("")

    # MethodId enum
    if idl.methods:
        w("    enum MethodId : std::uint16_t")
        w("    {")
        for m in idl.methods:
            w(f"        k{m.name} = {m.method_id},")
        w("    };")
        w("")

    # NotifyId enum
    if idl.notifications:
        w("    enum NotifyId : std::uint16_t")
        w("    {")
        for n in idl.notifications:
            w(f"        k{n.name} = {n.notify_id},")
        w("    };")
        w("")

    # run() method
    w("    void run();")
    w("")

    # Notification senders (take destination ThreadId)
    for n in idl.notifications:
        parts = ["kernel::ThreadId dest"]
        parts.extend([_param_decl(p, idl, is_out=False) for p in n.params])
        w(f"    std::int32_t notify{n.name}({', '.join(parts)});")

    if idl.notifications:
        w("")

    w("    virtual ~" + name + "Server() = default;")
    w("")
    w("protected:")

    # Pure virtual handlers
    for m in idl.methods:
        in_params = [p for p in m.params if p.direction == "in"]
        out_params = [p for p in m.params if p.direction == "out"]
        parts = []
        for p in in_params:
            parts.append(_param_decl(p, idl, is_out=False))
        for p in out_params:
            parts.append(_param_decl(p, idl, is_out=True))
        w(f"    virtual std::int32_t handle{m.name}({', '.join(parts)}) = 0;")

    w("")
    w("private:")
    w("    void dispatch(const kernel::Message &request);")
    w("};")
    w("")
    w("}  // namespace ipc")
    w("}  // namespace kernel")
    w("")

    return "\n".join(lines)


# -- Server implementation -------------------------------------------------

def emit_server_cpp(idl: IdlFile) -> str:
    name = idl.service_name
    lines = []
    w = lines.append

    w("// Auto-generated by ipcgen (embedded) -- do not edit.")
    w(f'#include "{name}Server.h"')
    w("")
    w("namespace kernel")
    w("{")
    w("namespace ipc")
    w("{")
    w("")

    # run()
    w(f"void {name}Server::run()")
    w("{")
    w("    kernel::Message msg;")
    w("    while (true)")
    w("    {")
    w("        std::int32_t rc = kernel::messageReceive(&msg);")
    w("        if (rc == kernel::kIpcOk)")
    w("        {")
    w("            dispatch(msg);")
    w("        }")
    w("    }")
    w("}")
    w("")

    # dispatch()
    w(f"void {name}Server::dispatch(const kernel::Message &request)")
    w("{")
    w("    kernel::Message reply;")
    w("    std::memset(&reply, 0, sizeof(reply));")
    w("    reply.type = static_cast<std::uint8_t>(kernel::MessageType::Reply);")
    w(f"    reply.serviceId = kServiceId;")
    w("    reply.methodId = request.methodId;")
    w("")
    w("    switch (request.methodId)")
    w("    {")

    for m in idl.methods:
        in_params = [p for p in m.params if p.direction == "in"]
        out_params = [p for p in m.params if p.direction == "out"]

        w(f"    case k{m.name}:")
        w("    {")

        # Static assert for payload sizes
        if in_params:
            in_parts = _total_wire_size_parts(in_params, idl)
            w(f"        static_assert({' + '.join(in_parts)} <= kernel::kMaxPayloadSize,")
            w(f'            "{m.name}: [in] params exceed payload limit");')

        if out_params:
            out_parts = _total_wire_size_parts(out_params, idl)
            w(f"        static_assert({' + '.join(out_parts)} <= kernel::kMaxPayloadSize,")
            w(f'            "{m.name}: [out] params exceed payload limit");')

        # Unmarshal [in] params
        if in_params:
            offset = "0"
            for i, p in enumerate(in_params):
                base = _resolve_type(p.type_name, idl)
                if p.type_name == "string":
                    w(f"        char {p.name}[{p.array_size + 1}];")
                    sz = str(p.array_size + 1)
                    if i == 0:
                        w(f"        std::memcpy({p.name}, request.payload, {sz});")
                        offset = sz
                    else:
                        w(f"        std::memcpy({p.name}, request.payload + {offset}, {sz});")
                        offset = f"{offset} + {sz}"
                    w(f"        {p.name}[{p.array_size}] = '\\0';")
                elif p.array_size is not None:
                    sz = f"{p.array_size} * sizeof({base})"
                    w(f"        {base} {p.name}[{p.array_size}];")
                    if i == 0:
                        w(f"        std::memcpy({p.name}, request.payload, {sz});")
                        offset = sz
                    else:
                        w(f"        std::memcpy({p.name}, request.payload + {offset}, {sz});")
                        offset = f"{offset} + {sz}"
                else:
                    sz = f"sizeof({base})"
                    w(f"        {base} {p.name};")
                    if i == 0:
                        w(f"        std::memcpy(&{p.name}, request.payload, {sz});")
                        offset = sz
                    else:
                        w(f"        std::memcpy(&{p.name}, request.payload + {offset}, {sz});")
                        offset = f"{offset} + {sz}"

        # Declare [out] vars
        for p in out_params:
            base = _resolve_type(p.type_name, idl)
            if p.type_name == "string":
                w(f"        char {p.name}[{p.array_size + 1}] = {{}};")
            elif p.array_size is not None:
                w(f"        {base} {p.name}[{p.array_size}] = {{}};")
            else:
                w(f"        {base} {p.name} = {{}};")

        # Call handler
        out_args = []
        for p in out_params:
            if p.type_name == "string" or p.array_size is not None:
                out_args.append(p.name)
            else:
                out_args.append(f"&{p.name}")
        call_args = [p.name for p in in_params] + out_args
        w(f"        reply.status = handle{m.name}({', '.join(call_args)});")

        # Marshal [out] params
        if out_params:
            offset = "0"
            for i, p in enumerate(out_params):
                base = _resolve_type(p.type_name, idl)
                if p.type_name == "string" or p.array_size is not None:
                    src = p.name
                else:
                    src = f"&{p.name}"
                sz = _wire_size(p, idl)
                if i == 0:
                    w(f"        std::memcpy(reply.payload, {src}, {sz});")
                    offset = sz
                else:
                    w(f"        std::memcpy(reply.payload + {offset}, {src}, {sz});")
                    offset = f"{offset} + {sz}"

            w(f"        reply.payloadSize = static_cast<std::uint16_t>({' + '.join(_total_wire_size_parts(out_params, idl))});")

        w("        break;")
        w("    }")

    w("    default:")
    w("        reply.status = kernel::kIpcErrMethod;")
    w("        break;")
    w("    }")
    w("")
    w("    kernel::messageReply(request.sender, reply);")
    w("}")

    # Notification senders
    for n in idl.notifications:
        w("")
        parts = ["kernel::ThreadId dest"]
        parts.extend([_param_decl(p, idl, is_out=False) for p in n.params])
        w(f"std::int32_t {name}Server::notify{n.name}({', '.join(parts)})")
        w("{")

        if n.params:
            w("    kernel::Message msg;")
            w("    std::memset(&msg, 0, sizeof(msg));")
            w("    msg.type = static_cast<std::uint8_t>(kernel::MessageType::Notify);")
            w(f"    msg.serviceId = kServiceId;")
            w(f"    msg.methodId = k{n.name};")

            # Static assert for notification params
            parts_sz = _total_wire_size_parts(n.params, idl)
            w(f"    static_assert({' + '.join(parts_sz)} <= kernel::kMaxPayloadSize,")
            w(f'        "{n.name}: notification params exceed payload limit");')

            offset = "0"
            for i, p in enumerate(n.params):
                base = _resolve_type(p.type_name, idl)
                sz = _wire_size(p, idl)
                if p.type_name == "string":
                    buf = f"_{p.name}"
                    w(f"    char {buf}[{p.array_size + 1}] = {{}};")
                    w(f"    std::strncpy({buf}, {p.name}, {p.array_size});")
                    src = buf
                elif p.array_size is not None:
                    src = p.name
                else:
                    src = f"&{p.name}"
                if i == 0:
                    w(f"    std::memcpy(msg.payload, {src}, {sz});")
                    offset = sz
                else:
                    w(f"    std::memcpy(msg.payload + {offset}, {src}, {sz});")
                    offset = f"{offset} + {sz}"

            w(f"    msg.payloadSize = static_cast<std::uint16_t>({' + '.join(parts_sz)});")
            w("    return kernel::messageTrySend(dest, msg);")
        else:
            w(f"    return kernel::messageNotify(dest, 1u << k{n.name});")

        w("}")

    w("")
    w("}  // namespace ipc")
    w("}  // namespace kernel")
    w("")

    return "\n".join(lines)


# -- Client header ----------------------------------------------------------

def emit_client_h(idl: IdlFile) -> str:
    name = idl.service_name
    service_id = fnv1a_32(name)
    lines = []
    w = lines.append

    w("// Auto-generated by ipcgen (embedded) -- do not edit.")
    w("#pragma once")
    w("")
    w('#include "kernel/Ipc.h"')
    if idl.enums or idl.structs:
        w(f'#include "{name}Types.h"')
    w("")
    w("#include <cstdint>")
    w("#include <cstring>")
    w("")
    w("namespace kernel")
    w("{")
    w("namespace ipc")
    w("{")
    w("")
    w(f"class {name}Client")
    w("{")
    w("public:")
    w(f"    explicit {name}Client(kernel::ThreadId serverTid)")
    w("        : m_serverTid(serverTid)")
    w("    {")
    w("    }")
    w("")
    w(f"    static constexpr std::uint32_t kServiceId = 0x{service_id:08x}u;")
    w("")

    # MethodId enum
    if idl.methods:
        w("    enum MethodId : std::uint16_t")
        w("    {")
        for m in idl.methods:
            w(f"        k{m.name} = {m.method_id},")
        w("    };")
        w("")

    # Method stubs
    for m in idl.methods:
        in_params = [p for p in m.params if p.direction == "in"]
        out_params = [p for p in m.params if p.direction == "out"]
        parts = []
        for p in in_params:
            parts.append(_param_decl(p, idl, is_out=False))
        for p in out_params:
            parts.append(_param_decl(p, idl, is_out=True))
        w(f"    std::int32_t {m.name}({', '.join(parts)});")

    w("")
    w("private:")
    w("    kernel::ThreadId m_serverTid;")
    w("};")
    w("")
    w("}  // namespace ipc")
    w("}  // namespace kernel")
    w("")

    return "\n".join(lines)


# -- Client implementation -------------------------------------------------

def emit_client_cpp(idl: IdlFile) -> str:
    name = idl.service_name
    lines = []
    w = lines.append

    w("// Auto-generated by ipcgen (embedded) -- do not edit.")
    w(f'#include "{name}Client.h"')
    w("")
    w("namespace kernel")
    w("{")
    w("namespace ipc")
    w("{")

    for m in idl.methods:
        in_params = [p for p in m.params if p.direction == "in"]
        out_params = [p for p in m.params if p.direction == "out"]

        parts = []
        for p in in_params:
            parts.append(_param_decl(p, idl, is_out=False))
        for p in out_params:
            parts.append(_param_decl(p, idl, is_out=True))

        w("")
        w(f"std::int32_t {name}Client::{m.name}({', '.join(parts)})")
        w("{")

        # Static asserts
        if in_params:
            in_sz = _total_wire_size_parts(in_params, idl)
            w(f"    static_assert({' + '.join(in_sz)} <= kernel::kMaxPayloadSize,")
            w(f'        "{m.name}: [in] params exceed payload limit");')

        if out_params:
            out_sz = _total_wire_size_parts(out_params, idl)
            w(f"    static_assert({' + '.join(out_sz)} <= kernel::kMaxPayloadSize,")
            w(f'        "{m.name}: [out] params exceed payload limit");')

        # Build request message
        w("    kernel::Message request;")
        w("    std::memset(&request, 0, sizeof(request));")
        w("    request.type = static_cast<std::uint8_t>(kernel::MessageType::Request);")
        w(f"    request.serviceId = kServiceId;")
        w(f"    request.methodId = k{m.name};")

        # Marshal [in] params
        if in_params:
            offset = "0"
            for i, p in enumerate(in_params):
                base = _resolve_type(p.type_name, idl)
                sz = _wire_size(p, idl)
                if p.type_name == "string":
                    buf = f"_{p.name}"
                    w(f"    char {buf}[{p.array_size + 1}] = {{}};")
                    w(f"    std::strncpy({buf}, {p.name}, {p.array_size});")
                    src = buf
                elif p.array_size is not None:
                    src = p.name
                else:
                    src = f"&{p.name}"
                if i == 0:
                    w(f"    std::memcpy(request.payload, {src}, {sz});")
                    offset = sz
                else:
                    w(f"    std::memcpy(request.payload + {offset}, {src}, {sz});")
                    offset = f"{offset} + {sz}"

            w(f"    request.payloadSize = static_cast<std::uint16_t>({' + '.join(_total_wire_size_parts(in_params, idl))});")
        else:
            w("    request.payloadSize = 0;")

        # Send and wait for reply
        w("")
        w("    kernel::Message reply;")
        w("    std::int32_t rc = kernel::messageSend(m_serverTid, request, &reply);")
        w("    if (rc != kernel::kIpcOk)")
        w("    {")
        w("        return rc;")
        w("    }")

        # Unmarshal [out] params
        if out_params:
            w("")
            offset = "0"
            for i, p in enumerate(out_params):
                base = _resolve_type(p.type_name, idl)
                sz = _wire_size(p, idl)
                if p.type_name == "string" or p.array_size is not None:
                    dst = p.name
                else:
                    dst = p.name
                if i == 0:
                    w(f"    if ({p.name} != nullptr)")
                    if p.type_name == "string" or p.array_size is not None:
                        w(f"        std::memcpy({dst}, reply.payload, {sz});")
                    else:
                        w(f"        std::memcpy({dst}, reply.payload, {sz});")
                    offset = sz
                else:
                    w(f"    if ({p.name} != nullptr)")
                    if p.type_name == "string" or p.array_size is not None:
                        w(f"        std::memcpy({dst}, reply.payload + {offset}, {sz});")
                    else:
                        w(f"        std::memcpy({dst}, reply.payload + {offset}, {sz});")
                    offset = f"{offset} + {sz}"

        w("")
        w("    return reply.status;")
        w("}")

    w("")
    w("}  // namespace ipc")
    w("}  // namespace kernel")
    w("")

    return "\n".join(lines)
