// Auto-generated by ipcgen (embedded) -- do not edit.
#include "EchoServer.h"

namespace kernel
{
namespace ipc
{

void EchoServer::run()
{
    kernel::Message msg;
    while (true)
    {
        std::int32_t rc = kernel::messageReceive(&msg);
        if (rc == kernel::kIpcOk)
        {
            dispatch(msg);
        }
    }
}

void EchoServer::dispatch(const kernel::Message &request)
{
    kernel::Message reply;
    std::memset(&reply, 0, sizeof(reply));
    reply.type = static_cast<std::uint8_t>(kernel::MessageType::Reply);
    reply.serviceId = kServiceId;
    reply.methodId = request.methodId;

    switch (request.methodId)
    {
    case kPing:
    {
        static_assert(sizeof(uint32_t) <= kernel::kMaxPayloadSize,
            "Ping: [in] params exceed payload limit");
        static_assert(sizeof(uint32_t) <= kernel::kMaxPayloadSize,
            "Ping: [out] params exceed payload limit");
        uint32_t value;
        std::memcpy(&value, request.payload, sizeof(uint32_t));
        uint32_t result = {};
        reply.status = handlePing(value, &result);
        std::memcpy(reply.payload, &result, sizeof(uint32_t));
        reply.payloadSize = static_cast<std::uint16_t>(sizeof(uint32_t));
        break;
    }
    case kAdd:
    {
        static_assert(sizeof(uint32_t) + sizeof(uint32_t) <= kernel::kMaxPayloadSize,
            "Add: [in] params exceed payload limit");
        static_assert(sizeof(uint32_t) <= kernel::kMaxPayloadSize,
            "Add: [out] params exceed payload limit");
        uint32_t a;
        std::memcpy(&a, request.payload, sizeof(uint32_t));
        uint32_t b;
        std::memcpy(&b, request.payload + sizeof(uint32_t), sizeof(uint32_t));
        uint32_t sum = {};
        reply.status = handleAdd(a, b, &sum);
        std::memcpy(reply.payload, &sum, sizeof(uint32_t));
        reply.payloadSize = static_cast<std::uint16_t>(sizeof(uint32_t));
        break;
    }
    case kGetCount:
    {
        static_assert(sizeof(uint32_t) <= kernel::kMaxPayloadSize,
            "GetCount: [out] params exceed payload limit");
        uint32_t count = {};
        reply.status = handleGetCount(&count);
        std::memcpy(reply.payload, &count, sizeof(uint32_t));
        reply.payloadSize = static_cast<std::uint16_t>(sizeof(uint32_t));
        break;
    }
    default:
        reply.status = kernel::kIpcErrMethod;
        break;
    }

    kernel::messageReply(request.sender, reply);
}

std::int32_t EchoServer::notifyCountChanged(kernel::ThreadId dest, uint32_t newCount)
{
    kernel::Message msg;
    std::memset(&msg, 0, sizeof(msg));
    msg.type = static_cast<std::uint8_t>(kernel::MessageType::Notify);
    msg.serviceId = kServiceId;
    msg.methodId = kCountChanged;
    static_assert(sizeof(uint32_t) <= kernel::kMaxPayloadSize,
        "CountChanged: notification params exceed payload limit");
    std::memcpy(msg.payload, &newCount, sizeof(uint32_t));
    msg.payloadSize = static_cast<std::uint16_t>(sizeof(uint32_t));
    return kernel::messageTrySend(dest, msg);
}

}  // namespace ipc
}  // namespace kernel
