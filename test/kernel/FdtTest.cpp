// FDT parser tests.
//
// Tests the kernel FDT parser against a known-good DTB binary
// (STM32F407ZGT6 board definition built by fdtlib.py).

#include "kernel/Fdt.h"

#include <gtest/gtest.h>
#include <cstdint>
#include <cstring>

namespace
{
    // Test DTB: STM32F407ZGT6 board (782 bytes, built by fdtlib.py)
    // Structure:
    //   / { compatible, model,
    //       board { name, mcu, arch },
    //       clocks { system-clock, apb1-clock, apb2-clock, hse-clock },
    //       memory { flash { reg }, sram { reg }, ccm { reg } },
    //       console { uart, baud, tx { port, pin, af }, rx { port, pin, af } },
    //       led { port, pin },
    //       features { fpu }
    //   }
    // clang-format off
    static const std::uint8_t kTestDtb[] = {
        0xd0, 0x0d, 0xfe, 0xed, 0x00, 0x00, 0x03, 0x0e,
        0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x02, 0xa4,
        0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x11,
        0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x6a, 0x00, 0x00, 0x02, 0x6c,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x14,
        0x00, 0x00, 0x00, 0x00, 0x6d, 0x73, 0x2d, 0x6f,
        0x73, 0x2c, 0x73, 0x74, 0x6d, 0x33, 0x32, 0x66,
        0x34, 0x30, 0x37, 0x7a, 0x67, 0x74, 0x36, 0x00,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0e,
        0x00, 0x00, 0x00, 0x0b, 0x53, 0x54, 0x4d, 0x33,
        0x32, 0x46, 0x34, 0x30, 0x37, 0x5a, 0x47, 0x54,
        0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x62, 0x6f, 0x61, 0x72, 0x64, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0e,
        0x00, 0x00, 0x00, 0x11, 0x53, 0x54, 0x4d, 0x33,
        0x32, 0x46, 0x34, 0x30, 0x37, 0x5a, 0x47, 0x54,
        0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x16,
        0x53, 0x54, 0x4d, 0x33, 0x32, 0x46, 0x34, 0x30,
        0x37, 0x5a, 0x47, 0x54, 0x36, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0a,
        0x00, 0x00, 0x00, 0x1a, 0x63, 0x6f, 0x72, 0x74,
        0x65, 0x78, 0x2d, 0x6d, 0x34, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
        0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x1f, 0x0a, 0x03, 0x7a, 0x00,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x2c, 0x02, 0x80, 0xde, 0x80,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x37, 0x05, 0x01, 0xbd, 0x00,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x42, 0x00, 0x7a, 0x12, 0x00,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
        0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x66, 0x6c, 0x61, 0x73,
        0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x4c,
        0x08, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
        0x73, 0x72, 0x61, 0x6d, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x00, 0x00, 0x4c, 0x20, 0x00, 0x00, 0x00,
        0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x01, 0x63, 0x63, 0x6d, 0x00,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x00, 0x00, 0x4c, 0x10, 0x00, 0x00, 0x00,
        0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
        0x63, 0x6f, 0x6e, 0x73, 0x6f, 0x6c, 0x65, 0x00,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x07,
        0x00, 0x00, 0x00, 0x50, 0x75, 0x73, 0x61, 0x72,
        0x74, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x55,
        0x00, 0x01, 0xc2, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x74, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x5a,
        0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x5f,
        0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x63,
        0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x01, 0x72, 0x78, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x5a, 0x41, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x00, 0x0a,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x07,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x01, 0x6c, 0x65, 0x64, 0x00,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x5a, 0x43, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x00, 0x0d,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
        0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x09, 0x63, 0x6f, 0x6d, 0x70,
        0x61, 0x74, 0x69, 0x62, 0x6c, 0x65, 0x00, 0x6d,
        0x6f, 0x64, 0x65, 0x6c, 0x00, 0x6e, 0x61, 0x6d,
        0x65, 0x00, 0x6d, 0x63, 0x75, 0x00, 0x61, 0x72,
        0x63, 0x68, 0x00, 0x73, 0x79, 0x73, 0x74, 0x65,
        0x6d, 0x2d, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x00,
        0x61, 0x70, 0x62, 0x31, 0x2d, 0x63, 0x6c, 0x6f,
        0x63, 0x6b, 0x00, 0x61, 0x70, 0x62, 0x32, 0x2d,
        0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x00, 0x68, 0x73,
        0x65, 0x2d, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x00,
        0x72, 0x65, 0x67, 0x00, 0x75, 0x61, 0x72, 0x74,
        0x00, 0x62, 0x61, 0x75, 0x64, 0x00, 0x70, 0x6f,
        0x72, 0x74, 0x00, 0x70, 0x69, 0x6e, 0x00, 0x61,
        0x66, 0x00, 0x66, 0x70, 0x75, 0x00
    };
    // clang-format on

    static constexpr std::uint32_t kTestDtbSize = sizeof(kTestDtb);

}  // namespace

using namespace kernel::fdt;

// ---- Header validation ----

TEST(FdtTest, Validate_ValidDtb)
{
    EXPECT_TRUE(validate(kTestDtb, kTestDtbSize));
}

TEST(FdtTest, Validate_BadMagic)
{
    std::uint8_t bad[40] = {};
    EXPECT_FALSE(validate(bad, sizeof(bad)));
}

TEST(FdtTest, Validate_TruncatedHeader)
{
    EXPECT_FALSE(validate(kTestDtb, 10));
}

TEST(FdtTest, Validate_NullPointer)
{
    EXPECT_FALSE(validate(nullptr, 0));
}

TEST(FdtTest, Validate_SizeTooSmall)
{
    EXPECT_FALSE(validate(kTestDtb, 0));
}

// ---- findNode ----

TEST(FdtTest, FindNode_Root)
{
    std::int32_t off = findNode(kTestDtb, "/");
    EXPECT_GE(off, 0);
}

TEST(FdtTest, FindNode_Board)
{
    std::int32_t off = findNode(kTestDtb, "/board");
    EXPECT_GE(off, 0);
}

TEST(FdtTest, FindNode_Clocks)
{
    std::int32_t off = findNode(kTestDtb, "/clocks");
    EXPECT_GE(off, 0);
}

TEST(FdtTest, FindNode_NestedPath)
{
    std::int32_t off = findNode(kTestDtb, "/console/tx");
    EXPECT_GE(off, 0);
}

TEST(FdtTest, FindNode_DeeplyNested)
{
    std::int32_t off = findNode(kTestDtb, "/memory/flash");
    EXPECT_GE(off, 0);
}

TEST(FdtTest, FindNode_NotFound)
{
    std::int32_t off = findNode(kTestDtb, "/nonexistent");
    EXPECT_EQ(off, -1);
}

TEST(FdtTest, FindNode_PartialPathNotFound)
{
    std::int32_t off = findNode(kTestDtb, "/console/nonexistent");
    EXPECT_EQ(off, -1);
}

// ---- readString ----

TEST(FdtTest, ReadString_RootCompatible)
{
    std::int32_t off = findNode(kTestDtb, "/");
    ASSERT_GE(off, 0);

    const char *val = nullptr;
    EXPECT_TRUE(readString(kTestDtb, off, "compatible", val));
    EXPECT_STREQ(val, "ms-os,stm32f407zgt6");
}

TEST(FdtTest, ReadString_RootModel)
{
    std::int32_t off = findNode(kTestDtb, "/");
    ASSERT_GE(off, 0);

    const char *val = nullptr;
    EXPECT_TRUE(readString(kTestDtb, off, "model", val));
    EXPECT_STREQ(val, "STM32F407ZGT6");
}

TEST(FdtTest, ReadString_BoardName)
{
    std::int32_t off = findNode(kTestDtb, "/board");
    ASSERT_GE(off, 0);

    const char *val = nullptr;
    EXPECT_TRUE(readString(kTestDtb, off, "name", val));
    EXPECT_STREQ(val, "STM32F407ZGT6");
}

TEST(FdtTest, ReadString_BoardArch)
{
    std::int32_t off = findNode(kTestDtb, "/board");
    ASSERT_GE(off, 0);

    const char *val = nullptr;
    EXPECT_TRUE(readString(kTestDtb, off, "arch", val));
    EXPECT_STREQ(val, "cortex-m4");
}

TEST(FdtTest, ReadString_ConsoleUart)
{
    std::int32_t off = findNode(kTestDtb, "/console");
    ASSERT_GE(off, 0);

    const char *val = nullptr;
    EXPECT_TRUE(readString(kTestDtb, off, "uart", val));
    EXPECT_STREQ(val, "usart1");
}

TEST(FdtTest, ReadString_NotFound)
{
    std::int32_t off = findNode(kTestDtb, "/board");
    ASSERT_GE(off, 0);

    const char *val = nullptr;
    EXPECT_FALSE(readString(kTestDtb, off, "nonexistent", val));
}

// ---- readU32 ----

TEST(FdtTest, ReadU32_SystemClock)
{
    std::int32_t off = findNode(kTestDtb, "/clocks");
    ASSERT_GE(off, 0);

    std::uint32_t val = 0;
    EXPECT_TRUE(readU32(kTestDtb, off, "system-clock", val));
    EXPECT_EQ(val, 168000000u);
}

TEST(FdtTest, ReadU32_Apb1Clock)
{
    std::int32_t off = findNode(kTestDtb, "/clocks");
    ASSERT_GE(off, 0);

    std::uint32_t val = 0;
    EXPECT_TRUE(readU32(kTestDtb, off, "apb1-clock", val));
    EXPECT_EQ(val, 42000000u);
}

TEST(FdtTest, ReadU32_HseClock)
{
    std::int32_t off = findNode(kTestDtb, "/clocks");
    ASSERT_GE(off, 0);

    std::uint32_t val = 0;
    EXPECT_TRUE(readU32(kTestDtb, off, "hse-clock", val));
    EXPECT_EQ(val, 8000000u);
}

TEST(FdtTest, ReadU32_ConsoleBaud)
{
    std::int32_t off = findNode(kTestDtb, "/console");
    ASSERT_GE(off, 0);

    std::uint32_t val = 0;
    EXPECT_TRUE(readU32(kTestDtb, off, "baud", val));
    EXPECT_EQ(val, 115200u);
}

TEST(FdtTest, ReadU32_LedPin)
{
    std::int32_t off = findNode(kTestDtb, "/led");
    ASSERT_GE(off, 0);

    std::uint32_t val = 0;
    EXPECT_TRUE(readU32(kTestDtb, off, "pin", val));
    EXPECT_EQ(val, 13u);
}

TEST(FdtTest, ReadU32_TxPin)
{
    std::int32_t off = findNode(kTestDtb, "/console/tx");
    ASSERT_GE(off, 0);

    std::uint32_t val = 0;
    EXPECT_TRUE(readU32(kTestDtb, off, "pin", val));
    EXPECT_EQ(val, 9u);
}

TEST(FdtTest, ReadU32_NotFound)
{
    std::int32_t off = findNode(kTestDtb, "/clocks");
    ASSERT_GE(off, 0);

    std::uint32_t val = 0;
    EXPECT_FALSE(readU32(kTestDtb, off, "nonexistent", val));
}

// ---- hasProperty (boolean) ----

TEST(FdtTest, HasProperty_FpuPresent)
{
    std::int32_t off = findNode(kTestDtb, "/features");
    ASSERT_GE(off, 0);
    EXPECT_TRUE(hasProperty(kTestDtb, off, "fpu"));
}

TEST(FdtTest, HasProperty_NotPresent)
{
    std::int32_t off = findNode(kTestDtb, "/features");
    ASSERT_GE(off, 0);
    EXPECT_FALSE(hasProperty(kTestDtb, off, "dsp"));
}

// ---- readReg ----

TEST(FdtTest, ReadReg_Flash)
{
    std::int32_t off = findNode(kTestDtb, "/memory/flash");
    ASSERT_GE(off, 0);

    std::uint32_t base = 0;
    std::uint32_t size = 0;
    EXPECT_TRUE(readReg(kTestDtb, off, base, size));
    EXPECT_EQ(base, 0x08000000u);
    EXPECT_EQ(size, 0x100000u);
}

TEST(FdtTest, ReadReg_Sram)
{
    std::int32_t off = findNode(kTestDtb, "/memory/sram");
    ASSERT_GE(off, 0);

    std::uint32_t base = 0;
    std::uint32_t size = 0;
    EXPECT_TRUE(readReg(kTestDtb, off, base, size));
    EXPECT_EQ(base, 0x20000000u);
    EXPECT_EQ(size, 0x20000u);
}

TEST(FdtTest, ReadReg_Ccm)
{
    std::int32_t off = findNode(kTestDtb, "/memory/ccm");
    ASSERT_GE(off, 0);

    std::uint32_t base = 0;
    std::uint32_t size = 0;
    EXPECT_TRUE(readReg(kTestDtb, off, base, size));
    EXPECT_EQ(base, 0x10000000u);
    EXPECT_EQ(size, 0x10000u);
}

// ---- Child iteration ----

TEST(FdtTest, FirstChild_Root)
{
    std::int32_t root = findNode(kTestDtb, "/");
    ASSERT_GE(root, 0);

    std::int32_t child = firstChild(kTestDtb, root);
    EXPECT_GE(child, 0);

    const char *name = nodeName(kTestDtb, child);
    EXPECT_STREQ(name, "board");
}

TEST(FdtTest, NextSibling_AfterBoard)
{
    std::int32_t board = findNode(kTestDtb, "/board");
    ASSERT_GE(board, 0);

    std::int32_t sibling = nextSibling(kTestDtb, board);
    EXPECT_GE(sibling, 0);

    const char *name = nodeName(kTestDtb, sibling);
    EXPECT_STREQ(name, "clocks");
}

TEST(FdtTest, IterateMemoryChildren)
{
    std::int32_t mem = findNode(kTestDtb, "/memory");
    ASSERT_GE(mem, 0);

    int count = 0;
    std::int32_t child = firstChild(kTestDtb, mem);
    while (child >= 0)
    {
        ++count;
        child = nextSibling(kTestDtb, child);
    }
    EXPECT_EQ(count, 3);  // flash, sram, ccm
}

TEST(FdtTest, FirstChild_NoChildren)
{
    // The "features" node has only a property, no child nodes
    std::int32_t feat = findNode(kTestDtb, "/features");
    ASSERT_GE(feat, 0);

    std::int32_t child = firstChild(kTestDtb, feat);
    EXPECT_EQ(child, -1);
}

// ---- nodeName ----

TEST(FdtTest, NodeName_Root)
{
    std::int32_t off = findNode(kTestDtb, "/");
    ASSERT_GE(off, 0);
    const char *name = nodeName(kTestDtb, off);
    ASSERT_NE(name, nullptr);
    EXPECT_STREQ(name, "");
}

TEST(FdtTest, NodeName_Console)
{
    std::int32_t off = findNode(kTestDtb, "/console");
    ASSERT_GE(off, 0);
    const char *name = nodeName(kTestDtb, off);
    EXPECT_STREQ(name, "console");
}

// ---- findProperty raw ----

TEST(FdtTest, FindProperty_ReturnsData)
{
    std::int32_t off = findNode(kTestDtb, "/clocks");
    ASSERT_GE(off, 0);

    Property prop{};
    EXPECT_TRUE(findProperty(kTestDtb, off, "system-clock", prop));
    EXPECT_EQ(prop.size, 4u);
    ASSERT_NE(prop.data, nullptr);
}

TEST(FdtTest, FindProperty_NotFound)
{
    std::int32_t off = findNode(kTestDtb, "/clocks");
    ASSERT_GE(off, 0);

    Property prop{};
    EXPECT_FALSE(findProperty(kTestDtb, off, "missing", prop));
}
