<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Story of ms-os</title>
<style>
  @page {
    size: A4;
    margin: 2.5cm 2cm;
  }

  * { box-sizing: border-box; }

  body {
    font-family: 'Georgia', 'Times New Roman', serif;
    font-size: 11.5pt;
    line-height: 1.65;
    color: #1a1a1a;
    max-width: 700px;
    margin: 0 auto;
    padding: 2cm 1.5cm;
    background: #fff;
  }

  /* ---- Title Page ---- */
  .title-page {
    text-align: center;
    page-break-after: always;
    padding-top: 6cm;
  }
  .title-page h1 {
    font-size: 36pt;
    font-weight: 700;
    color: #1a3a5c;
    letter-spacing: 2px;
    margin-bottom: 0.2em;
  }
  .title-page .subtitle {
    font-size: 14pt;
    color: #5a7a9a;
    font-style: italic;
    margin-bottom: 3cm;
  }
  .title-page .meta {
    font-size: 11pt;
    color: #666;
    line-height: 2;
  }

  /* ---- Chapter headings ---- */
  h2.chapter {
    font-size: 22pt;
    color: #1a3a5c;
    border-bottom: 3px solid #c0392b;
    padding-bottom: 8px;
    margin-top: 2.5em;
    page-break-before: always;
  }
  h2.chapter .ch-num {
    display: block;
    font-size: 11pt;
    text-transform: uppercase;
    letter-spacing: 3px;
    color: #c0392b;
    font-weight: 400;
    margin-bottom: 4px;
  }

  h3 {
    font-size: 14pt;
    color: #2c3e50;
    margin-top: 1.8em;
    margin-bottom: 0.5em;
  }

  h4 {
    font-size: 12pt;
    color: #555;
    font-style: italic;
    margin-top: 1.4em;
    margin-bottom: 0.4em;
  }

  /* ---- Body text ---- */
  p { margin: 0.8em 0; text-align: justify; }

  strong { color: #1a3a5c; }

  em { color: #555; }

  .highlight {
    background: #fef9e7;
    border-left: 4px solid #f39c12;
    padding: 10px 14px;
    margin: 1.2em 0;
    font-size: 10.5pt;
  }

  .key-decision {
    background: #eaf2f8;
    border-left: 4px solid #2980b9;
    padding: 10px 14px;
    margin: 1.2em 0;
    font-size: 10.5pt;
  }

  .lesson {
    background: #fdedec;
    border-left: 4px solid #c0392b;
    padding: 10px 14px;
    margin: 1.2em 0;
    font-size: 10.5pt;
  }

  /* ---- Diagrams ---- */
  .diagram {
    background: #f8f9fa;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 16px 20px;
    margin: 1.5em 0;
    font-family: 'Courier New', monospace;
    font-size: 9.5pt;
    line-height: 1.4;
    white-space: pre;
    overflow-x: auto;
    color: #2c3e50;
  }
  .diagram .label {
    color: #c0392b;
    font-weight: bold;
  }
  .diagram .comment {
    color: #7f8c8d;
  }

  /* ---- Code ---- */
  code {
    font-family: 'Courier New', monospace;
    font-size: 10pt;
    background: #f0f0f0;
    padding: 1px 5px;
    border-radius: 3px;
    color: #c0392b;
  }

  pre {
    background: #2c3e50;
    color: #ecf0f1;
    padding: 14px 18px;
    border-radius: 4px;
    font-family: 'Courier New', monospace;
    font-size: 9.5pt;
    line-height: 1.5;
    overflow-x: auto;
    margin: 1.2em 0;
  }
  pre .kw { color: #e74c3c; }
  pre .str { color: #2ecc71; }
  pre .cmt { color: #7f8c8d; }
  pre .fn { color: #f39c12; }
  pre .num { color: #9b59b6; }

  /* ---- Tables ---- */
  table {
    border-collapse: collapse;
    width: 100%;
    margin: 1.2em 0;
    font-size: 10pt;
  }
  th {
    background: #1a3a5c;
    color: white;
    padding: 8px 12px;
    text-align: left;
    font-weight: 600;
  }
  td {
    padding: 6px 12px;
    border-bottom: 1px solid #ddd;
  }
  tr:nth-child(even) { background: #f8f9fa; }

  /* ---- Timeline ---- */
  .timeline {
    position: relative;
    padding-left: 30px;
    margin: 1.5em 0;
  }
  .timeline::before {
    content: '';
    position: absolute;
    left: 8px;
    top: 0;
    bottom: 0;
    width: 3px;
    background: #1a3a5c;
  }
  .timeline .event {
    position: relative;
    margin-bottom: 1.2em;
    padding-left: 10px;
  }
  .timeline .event::before {
    content: '';
    position: absolute;
    left: -26px;
    top: 6px;
    width: 12px;
    height: 12px;
    background: #c0392b;
    border-radius: 50%;
    border: 2px solid #fff;
    box-shadow: 0 0 0 2px #1a3a5c;
  }
  .timeline .event-title {
    font-weight: 700;
    color: #1a3a5c;
  }

  /* ---- Figures ---- */
  .figure {
    text-align: center;
    margin: 1.5em 0;
  }
  .figure .caption {
    font-size: 9.5pt;
    color: #666;
    font-style: italic;
    margin-top: 6px;
  }

  /* ---- Print ---- */
  @media print {
    body { padding: 0; max-width: none; }
    .no-print { display: none; }
    h2.chapter { page-break-before: always; }
    .diagram, pre, table, .highlight, .key-decision, .lesson {
      page-break-inside: avoid;
    }
  }

  /* ---- Epigraph ---- */
  .epigraph {
    font-style: italic;
    color: #666;
    text-align: right;
    margin: 2em 0;
    padding-right: 1em;
    font-size: 11pt;
  }
  .epigraph .attribution {
    font-size: 9.5pt;
    margin-top: 4px;
  }
</style>
</head>
<body>

<!-- ============================================================ -->
<!--                        TITLE PAGE                            -->
<!-- ============================================================ -->
<div class="title-page">
  <h1>ms-os</h1>
  <div class="subtitle">Building a Real-Time Operating System from Scratch</div>
  <div style="width: 60%; margin: 0 auto; border-top: 2px solid #1a3a5c; padding-top: 1.5cm;">
    <div class="meta">
      Target: ARM Cortex-M3 / M4 / A9<br>
      Language: C++17 + Assembly<br>
      Architecture: Microkernel<br>
      <br>
      February 2025 &mdash; Present
    </div>
  </div>
</div>

<!-- ============================================================ -->
<!--                    TABLE OF CONTENTS                         -->
<!-- ============================================================ -->
<h2 class="chapter" style="page-break-before: always;">
  <span class="ch-num">&nbsp;</span>
  Contents
</h2>

<div style="font-size: 11pt; line-height: 2.2;">
  <strong>Prologue</strong> &mdash; Why Build an OS?<br>
  <div style="margin-left: 2em; line-height: 1.8; font-size: 10pt; color: #555;">
    Why Build One at All? / Why Start Simple? / The Architecture
  </div>
  <strong>Chapter 1</strong> &mdash; Laying the Foundation (Phase 0)<br>
  <div style="margin-left: 2em; line-height: 1.8; font-size: 10pt; color: #555;">
    Setting Up the Environment / Test-Driven Development / The Dual Build System /
    The Register-Level HAL / Startup / First Light
  </div>
  <strong>Chapter 2</strong> &mdash; The Kernel Comes Alive (Phase 1)<br>
  <strong>Chapter 3</strong> &mdash; Teaching the OS to Multitask (Phase 2)<br>
  <strong>Chapter 4</strong> &mdash; Guarding Memory (Phase 3)<br>
  <strong>Chapter 5</strong> &mdash; New Horizons: The PYNQ-Z2 (Phase 4)<br>
  <div style="margin-left: 2em; line-height: 1.8; font-size: 10pt; color: #555;">
    Getting the Damn Thing to Talk / The RTOS Port / The Alignment Fault /
    The MMU Fix / The UART ID Problem / The L2 Cache Nightmare /
    JTAG Reload via Cache Invalidation / Clean SD Card Boot /
    The Remaining Battles / The Debugging Lessons
  </div>
  <strong>Epilogue</strong> &mdash; The Road Ahead<br>
  <strong>Appendix A</strong> &mdash; Hardware Targets<br>
  <strong>Appendix B</strong> &mdash; Project Timeline
</div>

<!-- ============================================================ -->
<!--                        PROLOGUE                              -->
<!-- ============================================================ -->
<h2 class="chapter">
  <span class="ch-num">Prologue</span>
  Why Build an OS?
</h2>

<div class="epigraph">
  "What I cannot create, I do not understand."
  <div class="attribution">&mdash; Richard Feynman</div>
</div>

<p>
Every embedded engineer has, at some point, stared at a blinking LED and
thought: <em>what if I built the entire software stack beneath this?</em>
Not just the blink loop, not just the HAL, but the scheduler that decides
when the LED thread runs, the memory allocator that gives it stack space,
the fault handler that catches it when things go wrong.
</p>

<p>
That question is the seed of <strong>ms-os</strong>.
</p>

<p>
The goal was ambitious but clear: build a <strong>real-time operating system
from scratch</strong>, in modern C++17, targeting real ARM hardware. A kernel
that boots on silicon, switches contexts in microseconds, inherits priorities
through mutexes, and prints a crash dump when the world falls apart.
</p>

<h3>Why Build One at All?</h3>

<p>
There is no shortage of excellent RTOSes in the world. FreeRTOS is battle-tested
and runs on billions of devices. ThreadX powers Azure IoT. Zephyr has a
thriving open-source community. We studied all three&mdash;their source code
lives on our development machine as reference implementations&mdash;and we
could have picked any of them and started writing applications immediately.
</p>

<p>
But using an RTOS and <em>understanding</em> an RTOS are two very different
things. We wanted to know what happens in the 50 nanoseconds between one
thread stopping and another starting. We wanted to understand <em>why</em>
PendSV runs at the lowest priority, not just that it does. We wanted to feel
the difference between a bitmap scheduler and a linked-list walk, not just
read about it in a textbook. The only way to truly learn these things is to
build them yourself, debug them on real hardware, and watch them break in
ways no tutorial ever warns you about.
</p>

<h3>Why Start Simple?</h3>

<p>
We chose an <strong>STM32F207ZGT6</strong> as the first target: a Cortex-M3
running at 120 MHz with 1 MB of flash and 128 KB of SRAM. This was a
deliberate choice. The Cortex-M3 is one of the simplest ARM cores that still
has a real exception model, an NVIC, and hardware stack frame management on
interrupt entry. There is no MMU, no cache hierarchy, no multi-core
complexity. When something goes wrong, there are fewer places to look. The
chip's reference manual is one document, not five.
</p>

<p>
Starting simple meant we could focus on getting the fundamentals right:
context switching, scheduling algorithms, synchronization primitives. Once
those worked correctly on a predictable single-core machine, we could
confidently port to more complex hardware&mdash;knowing that any new bugs
came from the port, not from the core RTOS logic. Later, a Cortex-M4
(STM32F407ZGT6) and a dual Cortex-A9 (Zynq-7020 on the PYNQ-Z2 board)
would join the family, each adding architectural challenges of its own.
</p>

<h3>The Architecture</h3>

<p>
We chose a <strong>microkernel architecture</strong>&mdash;minimal kernel
with user-space services&mdash;inspired by Minix and QNX. The kernel would
handle only scheduling, synchronization, and memory protection. Everything
else&mdash;drivers, IPC, process management&mdash;would live outside the
kernel.
</p>

<p>
This is the story of how we built it, one phase at a time.
</p>

<!-- ============================================================ -->
<!--                      CHAPTER 1                               -->
<!-- ============================================================ -->
<h2 class="chapter">
  <span class="ch-num">Chapter 1</span>
  Laying the Foundation
</h2>

<h4>Phase 0: Toolchain, HAL, and First Light</h4>

<p>
Before you can build an OS, you need to build the ground it stands on.
Phase 0 was about establishing the entire development infrastructure:
a reproducible development environment, the cross-compilation toolchain,
the build system, the testing strategy, and the Hardware Abstraction Layer.
</p>

<h3>Setting Up the Environment</h3>

<p>
The very first thing we did&mdash;before writing a single line of C++&mdash;was
make sure anyone could reproduce the build. We chose <strong>Nix</strong> as our
package manager, because it provides deterministic, reproducible environments
that work identically on any Linux machine. A single <code>flake.nix</code> at
the project root declares everything the project needs:
</p>

<pre>
<span class="cmt"># flake.nix -- the entire development environment in one file</span>
packages = [
  gcc-arm-embedded     <span class="cmt"># ARM GCC 12.3.1 cross-compiler</span>
  cmake                <span class="cmt"># Build system generator</span>
  ninja                <span class="cmt"># Fast parallel build tool</span>
  openocd              <span class="cmt"># On-chip debugger (JTAG/SWD)</span>
  gdb                  <span class="cmt"># GNU debugger</span>
  python3 + pyserial   <span class="cmt"># Serial console + test runner</span>
  python3 + pytest     <span class="cmt"># Python-level testing</span>
  git                  <span class="cmt"># Version control</span>
  stlink               <span class="cmt"># ST-Link utilities</span>
  clang-tools          <span class="cmt"># clang-format for code style</span>
];
</pre>

<p>
To enter the development environment, you type <code>nix develop</code>. Nix
downloads and caches the exact versions of every tool, isolated from the host
system. No manual installation steps, no version conflicts, no "it works on my
machine" problems. If the flake builds today, it builds identically a year from now.
</p>

<p>
Alongside the Nix shell, we created <code>build.py</code>&mdash;a Python wrapper
around CMake and Ninja that handles the common workflows:
</p>

<pre>
python3 build.py                          <span class="cmt"># Cross-compile for F207</span>
python3 build.py --target stm32f407zgt6   <span class="cmt"># Cross-compile for F407</span>
python3 build.py --target pynq-z2         <span class="cmt"># Cross-compile for PYNQ-Z2</span>
python3 build.py -t                       <span class="cmt"># Build + run host unit tests</span>
python3 build.py -f                       <span class="cmt"># Flash firmware via J-Link</span>
python3 build.py -c                       <span class="cmt"># Clean everything</span>
</pre>

<p>
The script auto-detects target mismatches (if you switch from F207 to F407, it
cleans and reconfigures automatically) and selects the right flash tool per target
(J-Link for STM32, OpenOCD for PYNQ-Z2).
</p>

<h3>The Development Paradigm: Test-Driven Development</h3>

<p>
From the very beginning, we committed to <strong>test-driven development (TDD)</strong>
for the entire RTOS. This might sound unusual for embedded systems, where the
traditional approach is to write code, flash it to hardware, and debug with
printf or a logic analyzer. But we believed that an RTOS kernel&mdash;where a
single bug in the scheduler can silently corrupt every thread&mdash;demanded a
higher standard of confidence.
</p>

<p>
The development cycle for every component follows a strict four-phase process:
</p>

<div class="diagram">
  <span class="label">Development Phases (mandatory, in order)</span>

  1. DESIGN     Write a design document: architecture, interfaces,
                data structures, algorithms, edge cases.

  2. TEST       Write unit tests first (Google Test on x86).
                Mock the hardware. Define the expected behavior
                before writing the implementation.

  3. IMPLEMENT  Write the real code. Run tests continuously.
                The implementation is done when all tests pass.

  4. DOCUMENT   Update the design docs with what was actually built.
                Record any deviations from the original design.
</div>

<p>
Why this order? Because writing tests first forces you to think about the
<em>interface</em> before the implementation. When you write a test for
<code>heapAlloc()</code> before writing the allocator, you have to decide: what
does it return on failure? What alignment guarantees does it make? What happens
if you free a null pointer? These questions get answered in the test, not
discovered later during debugging on hardware.
</p>

<p>
TDD also gives us a safety net for refactoring. When we added MPU support in
Phase 3, we had to modify thread creation to pre-compute MPU region values.
The existing 136 tests told us immediately whether we had broken anything.
Without them, we would have had to re-verify every feature manually on hardware.
</p>

<div class="highlight">
<strong>Test count:</strong> By Phase 3, the project has <strong>136 C++ unit
tests</strong> and <strong>17 Python tests</strong>, all running on the host
machine in seconds. No hardware required to verify the kernel logic.
</div>

<h3>The Dual Build System</h3>

<p>
TDD on embedded hardware requires solving a fundamental problem: the code runs
on ARM, but we want to test on x86. Our solution was a <strong>dual build
system</strong>. The same CMake project produces two completely different outputs
depending on context:
</p>

<div class="diagram">
                    CMakeLists.txt
                         |
            +------------+------------+
            |                         |
    CMAKE_CROSSCOMPILING?       Host Build (x86)
            |                         |
   ARM Firmware (.elf)          Unit Tests
   arm-none-eabi-gcc            Native GCC
   startup + hal + app          GoogleTest + mocks
   -> build/                    -> build-test/
</div>

<p>
The key technique is <strong>link-time mock substitution</strong>. The public HAL
headers (<code>hal/inc/hal/Gpio.h</code>, etc.) are shared between both builds.
On ARM, the real implementation files (<code>hal/src/stm32f4/Gpio.cpp</code>)
access hardware registers through volatile pointers. On x86, mock implementations
(<code>test/hal/MockGpio.cpp</code>) provide the same function symbols but record
every call into global vectors. The test files then assert on the recorded state:
</p>

<pre>
<span class="cmt">// GpioTest.cpp -- test runs on x86, no hardware needed</span>
TEST(GpioTest, ToggleSetsOutputDataRegister)
{
    hal::GpioConfig cfg{};
    cfg.port = hal::GpioPort::C;
    cfg.pin = 13;
    cfg.mode = hal::GpioMode::Output;
    hal::gpioInit(cfg);

    hal::gpioToggle(hal::GpioPort::C, 13);

    <span class="cmt">// Assert the mock recorded the correct register write</span>
    EXPECT_EQ(test::g_gpioWrites.back().port, hal::GpioPort::C);
    EXPECT_EQ(test::g_gpioWrites.back().pin, 13);
}
</pre>

<div class="key-decision">
<strong>Key Decision:</strong> No <code>#ifdef</code> in any <code>.cpp</code>
file. Platform selection is purely through directory structure and CMake. The
real and mock implementations live in different directories, and CMake picks
the right one at build time. This keeps the code clean and prevents the
tangled web of conditional compilation that plagues many embedded projects.
</div>

<h3>The Register-Level HAL</h3>

<p>
With the build system and testing strategy in place, we could start writing
actual hardware code. The first decision was whether to use ST's official HAL
library (stm32f2xx_hal). We deliberately chose <strong>not to</strong>.
</p>

<p>
ST's HAL is a thick abstraction layer with hundreds of source files, its own
interrupt handler conventions, and opinions about how you should structure
your application. For an RTOS that needs to own the interrupt vector table,
manage its own stack pointers, and control exactly when interrupts are enabled
or disabled, this kind of abstraction gets in the way. We wanted to understand
every instruction between our code and the silicon.
</p>

<p>
Instead, we wrote a minimal <strong>register-level HAL</strong> that reads and
writes peripheral registers directly through volatile pointers. Only three
modules were needed to bring the board to life:
</p>

<table>
<tr><th>Module</th><th>Purpose</th><th>Key Registers</th></tr>
<tr>
  <td><strong>RCC</strong></td>
  <td>Clock tree: enable peripheral clocks</td>
  <td>RCC_AHB1ENR, RCC_APB1ENR, RCC_APB2ENR</td>
</tr>
<tr>
  <td><strong>GPIO</strong></td>
  <td>Pin configuration and toggle (LED on PC13)</td>
  <td>GPIOx_MODER, GPIOx_ODR, GPIOx_BSRR</td>
</tr>
<tr>
  <td><strong>USART</strong></td>
  <td>Serial output (TX on PA9, 115200 baud)</td>
  <td>USART_BRR, USART_CR1, USART_SR, USART_DR</td>
</tr>
</table>

<p>
Each module followed the same directory pattern&mdash;design first, write tests
against mocks, then implement the real register access:
</p>

<div class="diagram">
  hal/
    inc/hal/          <span class="comment">&lt;-- Public headers (shared with tests)</span>
      Gpio.h
      Uart.h
      Rcc.h
    src/stm32f4/      <span class="comment">&lt;-- Real implementation (register access)</span>
      Gpio.cpp
      Uart.cpp
      Rcc.cpp
  test/hal/           <span class="comment">&lt;-- Mock implementation + tests</span>
      MockGpio.cpp
      MockRegisters.h
      GpioTest.cpp
</div>

<h3>Startup: From Reset to main()</h3>

<p>
With the HAL tested on x86, we needed startup code to actually run on the
microcontroller. The startup assembly (<code>Startup.s</code>) handles the
delicate moment between power-on and C++ code. On the STM32F207, the sequence is:
</p>

<div class="diagram">
  <span class="label">Reset_Handler</span>
       |
       +---> Copy .data from FLASH to SRAM
       +---> Zero .bss
       +---> __libc_init_array()     <span class="comment">// C++ static constructors</span>
       +---> SystemInit()
       |        |
       |        +---> Configure PLL: HSE 25MHz -> 120 MHz SYSCLK
       |        +---> Flash: 3 wait states, prefetch, I/D caches
       |        +---> APB1 = 30 MHz, APB2 = 60 MHz
       |
       +---> main()
</div>

<p>
The linker script (<code>Linker.ld</code>) maps the memory regions: 1 MB of flash
at 0x08000000 for code and constants, 128 KB of SRAM at 0x20000000 for data, BSS,
a 16 KB heap, and a 4 KB main stack at the top of memory.
</p>

<h3>First Light</h3>

<p>
The moment of truth came when the LED on PC13 blinked for the first time.
A simple delay loop, a GPIO toggle, and&mdash;confirmed through a webcam
pointed at the board&mdash;the LED was alive. Serial output followed shortly
after: <code>"ms-os on STM32F207"</code> at 115200 baud.
</p>

<p>
That first blink was the result of the entire toolchain working end to end:
Nix providing the compiler, CMake selecting the right sources, the linker
script placing code at the correct flash address, the startup assembly
configuring the PLL, and the register-level HAL toggling the right GPIO pin.
Every layer had been tested independently before this moment, and they all
came together on the first try.
</p>

<p>
Phase 0 was complete. We had a reproducible build environment, a tested HAL,
a disciplined development process, and a binary running on real hardware.
The foundation was solid.
</p>

<!-- ============================================================ -->
<!--                      CHAPTER 2                               -->
<!-- ============================================================ -->
<h2 class="chapter">
  <span class="ch-num">Chapter 2</span>
  The Kernel Comes Alive
</h2>

<h4>Phase 1: Threads, Context Switching, and Crash Dumps</h4>

<p>
With the foundation in place, it was time to build the kernel's core:
the ability to run multiple threads of execution on a single CPU.
This is the heart of any RTOS&mdash;the context switch.
</p>

<h3>The Thread Control Block</h3>

<p>
Every thread in ms-os is represented by a <strong>Thread Control Block (TCB)</strong>,
a 44-byte structure that holds everything the kernel needs to manage a thread's life:
</p>

<table>
<tr><th>Field</th><th>Size</th><th>Purpose</th></tr>
<tr><td><code>stackPointer</code></td><td>4B</td><td>Current SP (offset 0 for assembly)</td></tr>
<tr><td><code>state</code></td><td>1B</td><td>Inactive / Ready / Running / Blocked</td></tr>
<tr><td><code>id</code></td><td>1B</td><td>Thread ID (0-7)</td></tr>
<tr><td><code>basePriority</code></td><td>1B</td><td>Assigned priority (immutable)</td></tr>
<tr><td><code>currentPriority</code></td><td>1B</td><td>Effective (may be boosted)</td></tr>
<tr><td><code>name</code></td><td>4B</td><td>Debug name for crash dumps</td></tr>
<tr><td><code>stackBase</code></td><td>4B</td><td>Bottom of stack</td></tr>
<tr><td><code>stackSize</code></td><td>4B</td><td>Size in bytes</td></tr>
<tr><td><code>mpuStackRbar</code></td><td>4B</td><td>Pre-computed MPU region (Phase 3)</td></tr>
<tr><td><code>mpuStackRasr</code></td><td>4B</td><td>Pre-computed MPU config (Phase 3)</td></tr>
</table>

<p>
The <code>stackPointer</code> field sits at offset 0 deliberately. This means
the context switch assembly can load it with a single <code>ldr r0, [TCB, #0]</code>
instruction&mdash;no offset calculation needed in the hottest path of the kernel.
</p>

<h3>The Context Switch</h3>

<p>
On Cortex-M, context switching uses the <strong>PendSV</strong> exception.
PendSV runs at the lowest interrupt priority, guaranteeing it fires only after
all other ISRs complete. This is the entire context switch, in 11 steps:
</p>

<div class="diagram">
  <span class="label">PendSV_Handler</span> (Cortex-M)

   1. cpsid i              <span class="comment">// Disable interrupts</span>
   2. mrs r0, psp          <span class="comment">// Get thread's stack pointer</span>
   3. stmdb r0!, {r4-r11}  <span class="comment">// Push callee-saved registers</span>
   4. str r0, [currentTCB] <span class="comment">// Save SP in outgoing TCB</span>
   5. currentTCB = nextTCB <span class="comment">// Switch the global pointer</span>
   6. Load MPU RBAR/RASR   <span class="comment">// Update memory protection</span>
   7. ldr r0, [nextTCB]    <span class="comment">// Load incoming SP</span>
   8. ldmia r0!, {r4-r11}  <span class="comment">// Pop callee-saved registers</span>
   9. msr psp, r0          <span class="comment">// Set new stack pointer</span>
  10. cpsie i              <span class="comment">// Re-enable interrupts</span>
  11. bx 0xFFFFFFFD        <span class="comment">// Return to thread mode</span>
</div>

<p>
The magic number <code>0xFFFFFFFD</code> is the <strong>EXC_RETURN</strong>
value that tells the Cortex-M hardware: "return to Thread mode using the
Process Stack Pointer." The hardware automatically restores r0-r3, r12, LR,
PC, and xPSR from the stack.
</p>

<div class="highlight">
<strong>Performance:</strong> The entire context switch takes approximately
<strong>50 nanoseconds</strong> at 120 MHz, including the MPU region update
added in Phase 3. That's about 6 clock cycles for the software part.
</div>

<h3>The Initial Stack Frame</h3>

<p>
When a thread is created, we build a fake stack frame that looks exactly like
the thread was interrupted mid-execution. When the context switch "restores"
this frame, the CPU seamlessly begins executing the thread function:
</p>

<div class="diagram">
  High address (top of stack):
    +----------+
    |   xPSR   |  Thumb bit set (0x01000000)
    |    PC    |  --> thread entry function
    |    LR    |  --> kernelThreadExit()
    |   r12    |  0
    |  r3..r0  |  r0 = thread argument
    +----------+  <span class="comment">---- hardware restores above ----</span>
    | r11..r4  |  all zero (software-saved)
    +----------+
         ^
    stackPointer stored in TCB
</div>

<h3>When Things Go Wrong: Crash Dumps</h3>

<p>
An RTOS that silently hangs on a fault is useless. Phase 1 introduced a
<strong>three-layer crash dump system</strong> that prints a detailed
diagnostic over the serial port when a HardFault, MemManage, BusFault,
or UsageFault occurs:
</p>

<div class="diagram">
  <span class="label">Crash Dump Architecture</span>

  +-------------------+
  | FaultHandlers.s   |  Layer 1: Assembly
  | (arch-specific)   |  Captures registers, calls C++
  +-------------------+
           |
           v
  +-------------------+
  | CrashDumpArch.cpp |  Layer 2: Architecture decode
  | (arch-specific)   |  Decodes fault registers (CFSR, etc.)
  +-------------------+
           |
           v
  +-------------------+
  | CrashDump.cpp     |  Layer 3: Portable formatting
  | (shared)          |  Prints register dump, stack trace
  +-------------------+
           |
           v
  +-------------------+
  | CrashDumpBoard.cpp|  Board-specific UART output
  | (board-specific)  |  Polled TX, no interrupts, no RTOS
  +-------------------+
</div>

<p>
The crash dump output is designed to be <em>self-contained</em>: it uses polled
UART with no interrupts, no dynamic allocation, and no RTOS services. It can
print from any fault context, even if the kernel itself is corrupted.
</p>

<!-- ============================================================ -->
<!--                      CHAPTER 3                               -->
<!-- ============================================================ -->
<h2 class="chapter">
  <span class="ch-num">Chapter 3</span>
  Teaching the OS to Multitask
</h2>

<h4>Phase 2: The Priority Scheduler, Mutexes, and Semaphores</h4>

<p>
A context switch is just the mechanism. Phase 2 added the <em>policy</em>:
a preemptive priority-based scheduler that decides <em>which</em> thread
runs and <em>when</em> it runs.
</p>

<h3>The Bitmap Scheduler</h3>

<p>
The scheduler supports <strong>32 priority levels</strong> (0 = highest,
31 = lowest), with a per-priority FIFO queue. The key insight is a single
32-bit bitmap:
</p>

<div class="diagram">
  m_readyBitmap:

  Bit:  31 30 29 28  ...  3  2  1  0
        [0][0][1][0] ... [1][0][0][1]
                ^          ^        ^
                |          |        |
           Priority 29  Prio 3   Prio 0
           (1 thread)  (1 thread) (highest ready)

  Highest ready = __builtin_ctz(bitmap) = 0
  ARM instruction: RBIT + CLZ  -->  <span class="label">O(1)</span>
</div>

<p>
Each set bit indicates that at least one thread is ready at that priority level.
Finding the highest-priority ready thread is a single <code>__builtin_ctz</code>
(Count Trailing Zeros), which maps directly to the ARM <code>RBIT + CLZ</code>
instruction pair. <strong>O(1) scheduling, regardless of thread count.</strong>
</p>

<div class="key-decision">
<strong>Key Decision:</strong> 32 priorities with bitmap indexing. This matches
the Cortex-M NVIC convention (lower number = higher priority) and provides
constant-time scheduling. FreeRTOS uses a similar approach.
</div>

<h3>Time Slicing</h3>

<p>
Within the same priority level, threads share the CPU using <strong>round-robin
time slicing</strong>. Each thread has a configurable time slice (in ticks).
When a thread's slice expires, the scheduler moves it to the tail of its
priority queue and runs the next thread at the same level:
</p>

<div class="diagram">
  Priority 8 queue:    [Thread A] --> [Thread B] --> [Thread C]
                           ^                            |
                           |____________________________|
                                (round-robin rotation)

  SysTick fires every 1 ms.
  Thread A's slice expires after 10 ticks.
  A moves to tail, B runs next.
</div>

<h3>The Priority Inversion Problem</h3>

<p>
One of the most subtle bugs in RTOS design is <strong>priority inversion</strong>.
Imagine three threads:
</p>

<div class="diagram">
  Thread H (high priority)   -- needs Mutex M
  Thread M (medium priority) -- CPU-bound, doesn't need M
  Thread L (low priority)    -- holds Mutex M

  Without priority inheritance:
    1. L runs, acquires Mutex M
    2. H wakes up, preempts L, tries to lock M --> blocked
    3. M wakes up, preempts L (medium > low)
    4. M runs indefinitely. H starves.
       L can never finish to release M!

  <span class="label">Result: High-priority thread blocked by medium-priority thread.</span>
</div>

<p>
The solution is <strong>priority inheritance</strong>: when Thread H blocks on
a mutex held by Thread L, the kernel <em>temporarily boosts</em> L's priority
to match H's. This prevents Thread M from preempting L, allowing L to finish
quickly and release the mutex.
</p>

<div class="key-decision">
<strong>Key Decision:</strong> Priority inheritance is mandatory on all mutexes.
There is no option to create a non-inheriting mutex. This eliminates an entire
class of bugs at the cost of slightly more complex mutex code.
</div>

<h3>Synchronization Primitives</h3>

<p>
Phase 2 delivered two synchronization primitives:
</p>

<table>
<tr><th>Primitive</th><th>Properties</th><th>Use Case</th></tr>
<tr>
  <td><strong>Mutex</strong></td>
  <td>Recursive, priority-inheriting, ownership-tracked</td>
  <td>Protecting shared data structures</td>
</tr>
<tr>
  <td><strong>Semaphore</strong></td>
  <td>Counting (0..maxCount), no ownership, priority-sorted waiters</td>
  <td>Producer-consumer, resource counting</td>
</tr>
</table>

<p>
Both use a shared <strong>priority-sorted wait queue</strong>: when multiple
threads are waiting, the highest-priority one is woken first.
</p>

<h3>Sleep and the Tick</h3>

<p>
The <strong>SysTick</strong> timer fires every 1 millisecond. Each tick:
</p>

<ol>
  <li>Increments the global tick counter</li>
  <li>Checks sleeping threads (wake any whose timeout expired)</li>
  <li>Calls <code>scheduler.tick()</code> to check preemption and time slices</li>
  <li>If a context switch is needed, pends PendSV</li>
</ol>

<p>
<code>sleep(1000)</code> blocks a thread for approximately one second.
The wakeup is checked every tick, giving 1 ms resolution.
</p>

<!-- ============================================================ -->
<!--                      CHAPTER 4                               -->
<!-- ============================================================ -->
<h2 class="chapter">
  <span class="ch-num">Chapter 4</span>
  Guarding Memory
</h2>

<h4>Phase 3: Block Pool, Heap, and the MPU</h4>

<p>
With scheduling working, the next challenge was memory management.
An RTOS needs two things: fast, deterministic allocation for kernel objects,
and flexible allocation for user applications. Phase 3 delivered both,
plus hardware memory protection.
</p>

<h3>The Block Pool: O(1) Fixed-Size Allocation</h3>

<p>
For kernel-internal objects (TCBs, message buffers, timer blocks), we need
allocation that is <strong>deterministic</strong> and <strong>ISR-safe</strong>.
The Block Pool provides this through an embedded free-list:
</p>

<div class="diagram">
  <span class="label">Block Pool (embedded free-list)</span>

  freeHead
     |
     v
  +------+    +------+    +------+    +------+
  | next-+--->| next-+--->| next-+--->| NULL |
  |      |    |      |    |      |    |      |
  | 32B  |    | 32B  |    | 32B  |    | 32B  |
  +------+    +------+    +------+    +------+

  allocate(): pop head      <span class="comment">--> O(1)</span>
  free(ptr):  push to head  <span class="comment">--> O(1)</span>

  Each free block stores the "next" pointer in its own memory.
  No separate metadata table needed.
</div>

<p>
The minimum block size is <code>sizeof(void*)</code> (4 bytes on ARM), since
each free block must hold the next pointer. The <code>free()</code> function
validates bounds and alignment before accepting a pointer back.
</p>

<h3>The Heap: First-Fit with Coalescing</h3>

<p>
For user applications&mdash;<code>std::vector</code>, <code>std::unique_ptr</code>,
<code>new</code>/<code>delete</code>&mdash;we built a variable-size heap allocator
using the classic <strong>first-fit free-list with immediate coalescing</strong>:
</p>

<div class="diagram">
  <span class="label">Heap Free List (address-sorted)</span>

  sentinel                                          sentinel
  (head)                                            (end)
     |                                                 |
     v                                                 v
  +------+    +--------+    +--------+    +---------+  +------+
  | sz=0 |    | sz=64  |    | sz=256 |    | sz=1024 |  | sz=0 |
  | next-+--->| next  -+--->| next  -+--->| next   -+->| NULL |
  +------+    | (free) |    | ALLOC  |    | (free)  |  +------+
              +--------+    +--------+    +---------+
              0x20001000    0x20001040    0x20001140

  <span class="comment">Allocation: walk list, find first block >= size</span>
  <span class="comment">Free: insert at correct address, merge with neighbors</span>
</div>

<p>
The free list is kept <strong>sorted by address</strong>. This is the crucial
insight: when freeing a block, we can check if the previous and next blocks
in the list are physically adjacent. If so, we <strong>coalesce immediately</strong>,
merging them into a single larger block. This prevents fragmentation from
accumulating over time.
</p>

<div class="highlight">
<strong>Block header:</strong> 8 bytes. Bit 0 of the size field doubles as the
allocated/free flag. A sentinel block at the heap end (size=0, allocated)
eliminates boundary checks during coalescing.
</div>

<h3>C++ Operator Overloads</h3>

<p>
To make the heap seamless for C++ applications, we override the global
<code>operator new</code> and <code>operator delete</code> to route through
our heap. A <code>_sbrk</code> stub prevents newlib's malloc from competing.
This means standard C++ works naturally:
</p>

<pre>
<span class="kw">auto</span> vec = <span class="kw">std::make_unique</span>&lt;std::vector&lt;<span class="kw">int</span>&gt;&gt;();
vec-&gt;push_back(<span class="num">42</span>);  <span class="cmt">// Allocates from kernel heap</span>
<span class="cmt">// vec automatically freed when unique_ptr goes out of scope</span>
</pre>

<h3>The MPU: Hardware-Enforced Boundaries</h3>

<p>
The ARMv7-M Memory Protection Unit provides hardware enforcement of memory
access rules. We configure 6 of the 8 available regions:
</p>

<div class="diagram">
  <span class="label">MPU Region Map</span>

  Region 0: FLASH (0x08000000)      [Priv+Unpriv RO] [Execute OK]
  Region 1: Kernel SRAM (0x20000000) [Priv RW only]   [No Execute]
  Region 2: Peripherals (0x40000000) [Priv RW only]   [No Execute]
  Region 3: System (0xE0000000)      [Priv RW only]   [No Execute]
  Region 4: Thread Stack (dynamic)   [Full Access]    [No Execute]
  Region 5: Heap (from linker)       [Full Access]    [No Execute]

  Region 4 is updated on every context switch.
  RBAR/RASR pre-computed in TCB for speed.
</div>

<div class="key-decision">
<strong>Key Decision:</strong> <code>PRIVDEFENA = 1</code> (privileged default
map enabled). All threads currently run in privileged mode with default
memory access. The MPU primarily protects against wild pointer writes
and code execution from data regions. Full unprivileged thread isolation
is deferred to a future phase.
</div>

<!-- ============================================================ -->
<!--                      CHAPTER 5                               -->
<!-- ============================================================ -->
<h2 class="chapter">
  <span class="ch-num">Chapter 5</span>
  New Horizons: The PYNQ-Z2
</h2>

<h4>Phase 4: Porting to Cortex-A9</h4>

<div class="epigraph">
  "If debugging is the process of removing bugs, then programming
  must be the process of putting them in."
  <div class="attribution">&mdash; Edsger W. Dijkstra</div>
</div>

<p>
With the RTOS running on two Cortex-M targets (F207 and F407), we turned
to something fundamentally different: the <strong>PYNQ-Z2</strong> board,
built around the <strong>Xilinx Zynq-7020 SoC</strong>&mdash;a dual
Cortex-A9 MPCore at 650 MHz with 512 MB of DDR3.
</p>

<p>
This wasn't just a new chip. It was a <strong>new architecture</strong>.
Everything we knew about Cortex-M had to be re-examined. The exception model,
the context switch mechanism, the memory system, even the way you set up a
damn stack pointer&mdash;all different. And the debugging story that followed
would become the most intense, most frustrating, and ultimately most
satisfying chapter of this entire project.
</p>

<table>
<tr><th>Feature</th><th>Cortex-M</th><th>Cortex-A9</th></tr>
<tr><td>Instruction set</td><td>Thumb-2</td><td>ARM (32-bit)</td></tr>
<tr><td>Exception model</td><td>NVIC (nested, automatic stacking)</td><td>Banked modes (IRQ, SVC, ABT, etc.)</td></tr>
<tr><td>Context switch</td><td>PendSV (dedicated exception)</td><td>IRQ epilogue + SGI</td></tr>
<tr><td>Tick timer</td><td>SysTick (built-in)</td><td>SCU Private Timer</td></tr>
<tr><td>Memory protection</td><td>MPU (8 regions)</td><td>MMU (page tables)</td></tr>
<tr><td>Stack pointer</td><td>MSP/PSP (hardware banked)</td><td>Per-mode banked SP</td></tr>
<tr><td>First thread launch</td><td>SVC + EXC_RETURN</td><td>SVC + RFE</td></tr>
<tr><td>CPU count</td><td>Single core</td><td>Dual core (SMP capable)</td></tr>
</table>

<h3>Phase 4A: Getting the Damn Thing to Talk</h3>

<p>
The first order of business: prove that we can run <em>any</em> bare-metal
code on the Zynq. We wrote new startup assembly in ARM mode (not Thumb),
a DDR-based linker script, and a Zynq PS UART0 driver using the Cadence
UART IP. Simple stuff, right? The "hello world" of embedded. Spoiler: it
was anything but simple.
</p>

<h4>The FTDI Setup</h4>

<p>
The PYNQ-Z2 has an <strong>FTDI FT2232</strong> dual-channel USB chip.
Channel 0 is JTAG. Channel 1 is the serial console. On our Linux box, this
shows up as <code>/dev/ttyUSB1</code> for JTAG and <code>/dev/ttyUSB2</code>
for serial (because there's another FTDI device already claiming ttyUSB0).
</p>

<p>
OpenOCD talks to the JTAG channel. Our first config file:
</p>

<pre>
<span class="cmt"># pynq_load.cfg</span>
adapter driver ftdi
ftdi vid_pid 0x0403 0x6010
ftdi channel 0
ftdi layout_init 0x0008 0x000b
adapter speed 10000

set CHIPNAME zynq
source [find target/zynq_7000.cfg]
</pre>

<p>
The <code>ftdi layout_init</code> values (0x0008, 0x000b) configure the FTDI
GPIOs for JTAG signaling. Get these wrong and OpenOCD silently fails to
detect the TAP. We got these from the PYNQ-Z2 schematic.
</p>

<h4>Boot Strategy: Let u-boot Do the Hard Work</h4>

<p>
Zynq PS initialization is brutal. The Processing System (PS) has its own
PLL tree, DDR controller, MIO pin muxing, SLCR (System Level Control
Registers)&mdash;hundreds of registers that must be configured in the right
order before you can even access DDR memory. Xilinx normally generates a
<code>ps7_init.c</code> from the Vivado hardware design, and the FSBL
(First Stage Boot Loader) calls it during boot.
</p>

<p>
We took a shortcut: let the normal boot process (BootROM -> FSBL -> u-boot)
initialize the hardware, then halt via JTAG and load our binary into DDR.
This means u-boot has already configured PLLs, DDR, MIO pins&mdash;everything.
We just set our clock globals to match and go:
</p>

<pre>
<span class="cmt">// SystemInit.cpp for PYNQ-Z2 -- u-boot already configured clocks</span>
SystemCoreClock = <span class="num">650000000</span>;   <span class="cmt">// CPU at 650 MHz</span>
g_apb1Clock     = <span class="num">100000000</span>;   <span class="cmt">// UART ref clock at 100 MHz</span>
g_apb2Clock     = <span class="num">100000000</span>;
</pre>

<div class="key-decision">
<strong>Key Decision:</strong> Use u-boot for PS initialization during
development. This lets us focus on the RTOS itself rather than Zynq PS
bringup. A proper standalone boot (using <code>ps7_init</code> or our own
initialization) is deferred to when we write our custom bootloader.
</div>

<h4>The UART: Cadence IP, Not STM32</h4>

<p>
The Zynq PS UART is a <strong>Cadence UART</strong> IP core. Completely
different register layout from the STM32 USART. The baud rate formula alone
is different:
</p>

<div class="diagram">
  <span class="label">Baud Rate Calculation</span>

  STM32:  baud = f_pclk / USARTDIV
  Zynq:   baud = uart_ref_clk / (CD * (BDIV + 1))

  For 115200 baud with 100 MHz ref clock:
    BDIV = 4   (divider + 1 = 5)
    CD = 100,000,000 / (115,200 * 5) = 173.6  -->  CD = 173

  Actual baud = 100,000,000 / (173 * 5) = 115,607
  Error: 0.35%  (well within tolerance)
</pre>
</div>

<p>
PS UART0 lives at <code>0xE0000000</code>. UART1 at <code>0xE0001000</code>.
On the PYNQ-Z2, UART0 is connected to the FTDI chip for serial console
output. This distinction would come back to bite us later.
</p>

<h4>The First UART Bug: STARTBRK</h4>

<p>
Our first attempt at UART output produced... nothing. Absolute silence.
The UART was "enabled" according to the status register, but no characters
came out. We spent hours checking baud rate calculations, MIO pin
assignments, clock enables.
</p>

<p>
The problem? Our UART Control Register bit definitions were <strong>wrong</strong>.
We had defined bit 8 as "reset TX path" based on a quick read of the
register map. But bit 8 of the Cadence UART CR is actually
<code>STARTBRK</code>&mdash;it forces the TXD line permanently LOW,
asserting a break condition. We were telling the UART to hold the
line low forever while trying to transmit data on it.
</p>

<div class="lesson">
<strong>Lesson learned the hard way:</strong> Always cross-reference
register bit definitions against the actual TRM, not against quick
summaries or "similar" peripherals. One wrong bit in a control register
can produce symptoms that look like a completely different problem.
The CR register writes <code>STPBRK | TXEN | RXEN = 0x114</code>.
That took an embarrassingly long time to figure out.
</div>

<h4>Cross-Compilation Working</h4>

<p>
With the UART driver fixed and the build system extended for
<code>--target pynq-z2</code>, we could cross-compile both the hello app
and the full threads app. The binary sizes:
</p>

<table>
<tr><th>App</th><th>.text</th><th>Total</th></tr>
<tr><td>hello (bare-metal)</td><td>~2 KB</td><td>~2 KB</td></tr>
<tr><td>threads (full RTOS)</td><td>10,504 B</td><td>~42 KB</td></tr>
</table>

<p>
Both compiled cleanly. We loaded hello via JTAG and... got serial output!
Proof that the toolchain, linker script, startup assembly, and UART driver
all worked. Time to try the RTOS.
</p>

<h3>Phase 4B: The RTOS Port</h3>

<p>
The cross-compilation changes for Cortex-A9 RTOS were substantial. We had
to rethink every architecture-dependent component.
</p>

<h4>The Architecture Abstraction</h4>

<p>
To support both Cortex-M and Cortex-A9 from the same kernel source, we
introduced <code>kernel/inc/kernel/Arch.h</code>&mdash;a common interface
with per-architecture implementations selected at build time:
</p>

<div class="diagram">
  <span class="label">Arch.h (common interface)</span>

  arch::triggerContextSwitch()    <span class="comment">// M: PendSV    A9: SGI #0</span>
  arch::configureSysTick(ticks)   <span class="comment">// M: SysTick   A9: Private Timer</span>
  arch::enterCritical()           <span class="comment">// M: cpsid i   A9: cpsid i</span>
  arch::exitCritical()            <span class="comment">// M: cpsie i   A9: cpsie i</span>
  arch::startFirstThread()        <span class="comment">// M: SVC       A9: SVC</span>
  arch::initialStatusRegister()   <span class="comment">// M: 0x01000000 (Thumb)</span>
                                  <span class="comment">// A9: 0x1F (SYS mode, ARM)</span>
</div>

<h4>The Context Switch: No PendSV, No Problem (Sort Of)</h4>

<p>
On Cortex-M, context switching is beautiful. PendSV fires at the lowest
interrupt priority, guaranteeing it runs after all ISRs complete. The hardware
automatically saves half the register file on entry. You pend it from anywhere,
and it just... happens.
</p>

<p>
Cortex-A9 has none of that. There is no PendSV. There is no automatic register
stacking. There is no EXC_RETURN magic value. Instead, you have <strong>banked
processor modes</strong> (IRQ, SVC, SYS, ABT, UND, FIQ), each with their own
stack pointer and link register. The context switch happens <em>inside the
IRQ handler epilogue</em>:
</p>

<div class="diagram">
  <span class="label">Cortex-A9 Context Switch (in IRQ handler)</span>

  IRQ Entry:
    sub lr, lr, #4          <span class="comment">// Adjust return address (ARM pipeline)</span>
    srsdb sp!, #0x1F        <span class="comment">// Save {LR_irq, SPSR_irq} to SYS stack</span>
    cps #0x1F               <span class="comment">// Switch to SYS mode</span>
    push {r0-r3, r12, lr}   <span class="comment">// Save caller-saved regs on SYS stack</span>

  &lt;--- Acknowledge GIC, dispatch handler (timer / SGI) ---&gt;

  IRQ Epilogue (context switch point):
    if g_currentTcb != g_nextTcb:
      push {r4-r11}         <span class="comment">// Save callee-saved on outgoing stack</span>
      Save SP to outgoing TCB
      Switch TCB pointers
      Load SP from incoming TCB
      pop {r4-r11}          <span class="comment">// Restore callee-saved from incoming stack</span>

    pop {r0-r3, r12, lr}    <span class="comment">// Restore caller-saved</span>
    rfeia sp!                <span class="comment">// Atomically restore PC + CPSR</span>
</div>

<p>
The key instructions are <code>SRS</code> (Store Return State) and
<code>RFE</code> (Return From Exception). <code>SRS</code> saves the
interrupted thread's PC and CPSR to the <em>SYS mode stack</em>, even
though we're in IRQ mode when it executes. <code>RFE</code> atomically
restores both PC and CPSR from the stack, returning to the correct mode
and address. These are the A-profile equivalents of M-profile's automatic
stacking and EXC_RETURN.
</p>

<p>
For the trigger mechanism, we use <strong>SGI #0</strong> (Software Generated
Interrupt). When the scheduler decides a context switch is needed, it writes
to the GIC SGIR register to generate interrupt ID 0. The IRQ handler checks
the interrupt ID: if it's 29 (private timer), it handles the tick; if it's
0 (SGI), it's a context switch request. Either way, the epilogue checks
whether <code>g_currentTcb != g_nextTcb</code> and switches if needed.
</p>

<h4>The GIC and Private Timer</h4>

<p>
Cortex-M has the NVIC (simple, memory-mapped, one register per interrupt).
Cortex-A9 has the <strong>GIC</strong> (Generic Interrupt Controller)&mdash;a
two-part beast with a Distributor and a CPU Interface:
</p>

<div class="diagram">
  <span class="label">GIC Configuration</span>

  Distributor (0xF8F01000):
    DIST_CTRL = 0x3           <span class="comment">// Enable secure + non-secure</span>
    EN_SET0   = 0x2000FFFF    <span class="comment">// SGIs 0-15 + IRQ 29 (timer)</span>
    PRIORITY  = 0xA0 (timer)  <span class="comment">// Timer at priority 0xA0</span>
                0xF0 (SGI #0) <span class="comment">// SGI at lower priority 0xF0</span>

  CPU Interface (0xF8F00100):
    CPU_CTRL  = 0x3           <span class="comment">// Enable interface</span>
    PRI_MASK  = 0xF8          <span class="comment">// Allow priorities 0x00-0xF0</span>
</div>

<p>
The <strong>SCU Private Timer</strong> at <code>0xF8F00600</code> replaces
SysTick. It runs at PERIPHCLK = CPU_CLK/2 = 325 MHz. For a 1 ms tick:
load value = 325,000,000 / 1000 - 1 = 324,999 (<code>0x4F587</code>).
Auto-reload, interrupt enabled.
</p>

<h4>Crash Dumps on A-Profile</h4>

<p>
Cortex-M has dedicated fault status registers (CFSR, HFSR, MMFAR, BFAR)
that tell you exactly what went wrong. Cortex-A9 has different registers:
</p>

<table>
<tr><th>Cortex-M</th><th>Cortex-A9</th><th>Purpose</th></tr>
<tr><td>SCB->CFSR</td><td>CP15 DFSR / IFSR</td><td>Fault status (type + domain)</td></tr>
<tr><td>SCB->MMFAR</td><td>CP15 DFAR / IFAR</td><td>Faulting address</td></tr>
<tr><td>HardFault</td><td>Data Abort</td><td>Bad memory access</td></tr>
<tr><td>MemManage</td><td>Prefetch Abort</td><td>Instruction fetch fault</td></tr>
<tr><td>UsageFault</td><td>Undefined Instruction</td><td>Bad opcode</td></tr>
</table>

<p>
Our fault handlers pass a type code in <code>r1</code> (1=DataAbort,
2=PrefetchAbort, 3=Undefined) to the shared crash dump code. One fun
difference: ARM does <em>not</em> trap integer divide-by-zero (it returns 0
silently). For testing the crash dump, we use <code>UDF #0</code> (Undefined
Instruction) instead.
</p>

<h3>The Bringup: Where Everything Falls Apart (and Comes Back Together)</h3>

<p>
The cross-compilation was done. Both hello and threads built cleanly for
Cortex-A9. Time for hardware. What followed was one of the most intense
debugging sessions of the entire project&mdash;a roller coaster of
frustration, discovery, and hard-won victories.
</p>

<h4>First Boot Attempt: The Alignment Fault</h4>

<p>
We loaded the threads binary via JTAG, resumed at 0x00100000, and... the
CPU immediately faulted. Halted at the Data Abort handler. The registers
told the story:
</p>

<pre>
DFSR = 0x00000801
DFAR = 0x0010686B
PC   = somewhere in SystemInit()
</pre>

<p>
<code>DFSR = 0x801</code>. Bit 0 set = alignment fault. Bit 11 set = write
access. The faulting address <code>0x10686B</code> is clearly not
word-aligned&mdash;it ends in 0xB, not 0x0/0x4/0x8/0xC.
</p>

<p>
What the hell? We never had alignment problems on Cortex-M. Why would the
same kind of C++ code suddenly fault on unaligned access?
</p>

<p>
The answer hit us like a truck:
</p>

<div class="highlight">
<strong>On Cortex-A9 with MMU disabled, all memory is treated as
Strongly Ordered.</strong> Strongly Ordered memory requires <em>natural
alignment</em> for every access. A 32-bit store must go to a 4-byte-aligned
address. An 8-bit store is fine anywhere, but <code>str r4, [sp, #43]</code>
will fault because <code>sp + 43</code> is not 4-byte aligned.
</div>

<p>
GCC doesn't know or care about this. It freely emits unaligned stack accesses
because on Normal memory (which is what you get with the MMU enabled),
ARMv7-A handles unaligned access transparently in hardware. But with the
MMU disabled&mdash;which is the state we boot into&mdash;there is no
"Normal" memory type. Everything is Strongly Ordered. And Strongly Ordered
means: align your damn accesses or eat a Data Abort.
</p>

<p>
On Cortex-M, the MMU doesn't exist, but the default memory attributes treat
SRAM as Normal memory, so unaligned access just works. We'd never needed
to think about this. The M-profile architecture was quietly saving us from
ourselves. The A-profile was not so forgiving.
</p>

<h4>The Fix: Build an MMU Before Touching C++</h4>

<p>
The solution was clear but not trivial: we had to <strong>enable the MMU
with DDR mapped as Normal memory</strong> in the startup assembly, <em>before
any C code executes</em>. No calling SystemInit first. No calling <code>
__libc_init_array</code>. The MMU must be up and running before the first
<code>bl</code> to a C function, because even a function prologue might
push registers to an unaligned stack offset.
</p>

<p>
We implemented a flat 1:1 L1 translation table&mdash;4096 entries of 1 MB
sections covering the full 4 GB address space:
</p>

<div class="diagram">
  <span class="label">MMU L1 Translation Table (16 KB, 4096 x 4-byte entries)</span>

  Entry  0-511:   DDR (0x00000000 - 0x1FFFFFFF)
                  Normal, Inner/Outer Write-Back Write-Allocate, Shareable
                  Descriptor: 0x00011C0E
                    TEX=001, C=1, B=1, S=1, AP=11, Section (bits[1:0]=10)

  Entry 512-4095: Everything else (peripherals, PL, system registers)
                  Device, Shareable
                  Descriptor: 0x00000C06
                    TEX=000, C=0, B=1, AP=11, Section (bits[1:0]=10)
</div>

<p>
We validated the section descriptor bit fields against the Xilinx BSP
<code>translation_table.S</code> reference. The values match. TEX[2:0]=001,
C=1, B=1 gives Inner/Outer Write-Back Write-Allocate&mdash;the normal
cache policy for DDR memory.
</p>

<p>
The <code>_setup_mmu</code> routine in Startup.s builds this table at
runtime, sets TTBR0 (Translation Table Base Register 0), configures
DACR (Domain Access Control) to Manager mode (no permission checking),
and enables the MMU + I-cache + D-cache + branch prediction in SCTLR:
</p>

<pre>
<span class="cmt">// The critical sequence in Startup.s</span>
_setup_mmu:
    push    {r4, lr}

    <span class="cmt">// Fill 4096 entries: 512 Normal + 3584 Device</span>
    ldr     r0, =_mmu_table
    mov     r1, #0                  <span class="cmt">// Section base = 0x00000000</span>
    ldr     r2, =SECT_NORMAL        <span class="cmt">// 0x00011C0E</span>
    mov     r3, #512
1:  orr     r4, r2, r1
    str     r4, [r0], #4
    add     r1, r1, #0x00100000     <span class="cmt">// Next 1MB</span>
    subs    r3, r3, #1
    bne     1b

    ldr     r2, =SECT_DEVICE        <span class="cmt">// 0x00000C06</span>
    ldr     r3, =(4096 - 512)
2:  orr     r4, r2, r1
    str     r4, [r0], #4
    add     r1, r1, #0x00100000
    subs    r3, r3, #1
    bne     2b

    <span class="cmt">// Set TTBR0</span>
    ldr     r0, =_mmu_table
    mcr     p15, 0, r0, c2, c0, 0

    <span class="cmt">// DACR = Manager (full access, no permission check)</span>
    mvn     r0, #0                  <span class="cmt">// 0xFFFFFFFF</span>
    mcr     p15, 0, r0, c3, c0, 0

    <span class="cmt">// Enable MMU + caches + branch prediction in SCTLR</span>
    mrc     p15, 0, r0, c1, c0, 0
    orr     r0, r0, #(1 &lt;&lt; 0)      <span class="cmt">// MMU</span>
    orr     r0, r0, #(1 &lt;&lt; 2)      <span class="cmt">// D-cache</span>
    orr     r0, r0, #(1 &lt;&lt; 11)     <span class="cmt">// Branch prediction</span>
    orr     r0, r0, #(1 &lt;&lt; 12)     <span class="cmt">// I-cache</span>
    mcr     p15, 0, r0, c1, c0, 0
    dsb
    isb

    pop     {r4, pc}
</pre>

<p>
The linker script needed a new section for the 16 KB translation table,
aligned to 16 KB (TTBR0 requires this alignment):
</p>

<pre>
.mmu_table (NOLOAD) :
{
    . = ALIGN(16K);
    _mmu_table = .;
    . += 16K;
} > DDR
</pre>

<p>
The boot sequence now became:
</p>

<div class="diagram">
  <span class="label">Updated PYNQ-Z2 Boot Sequence</span>

  _boot:
    cpsid if                   <span class="comment">// Disable interrupts</span>
    Check MPIDR, park CPU1     <span class="comment">// Only CPU0 proceeds</span>
    Set VBAR                   <span class="comment">// Install our vector table</span>
    Disable MMU + caches       <span class="comment">// Clean slate from FSBL/u-boot</span>
    Invalidate TLBs            <span class="comment">// Stale translations</span>
    Invalidate I-cache         <span class="comment">// Stale instructions</span>
    Invalidate branch predictor
    Invalidate L1 D-cache      <span class="comment">// 4 ways x 256 sets</span>
    Disable + invalidate L2    <span class="comment">// PL310 (0xF8F02100)</span>
    <span class="label">bl _setup_mmu</span>              <span class="comment">// MMU ON before any C code!</span>
    Set per-mode stacks        <span class="comment">// IRQ, ABT, UND, FIQ, SVC, SYS</span>
    Zero .bss
    __libc_init_array          <span class="comment">// C++ static constructors</span>
    SystemInit                 <span class="comment">// Set clock globals</span>
    main()
</div>

<p>
Built it. The binary grew from 10,504 bytes to 10,696 bytes (the MMU table
setup code). Moment of truth.
</p>

<h4>Victory #1: The MMU Fix Works</h4>

<p>
We loaded the threads binary via JTAG, resumed, waited five seconds, then
halted CPU0 to check where it was:
</p>

<pre>
> targets zynq.cpu0
> halt
> reg pc
pc: 0x00102204
> reg cpsr
cpsr: 0x6000001F    <span class="cmt">// SYS mode (0x1F) -- threads run in SYS mode!</span>
</pre>

<p>
SCTLR confirmed MMU was ON. The CPU was sitting in
<code>kernel::arch::exitCritical()</code>&mdash;meaning the scheduler was
running, threads were switching, the RTOS was <em>alive</em>. No more
alignment faults.
</p>

<p>
We immediately checked the peripheral state via JTAG to verify the full
system was configured:
</p>

<pre>
<span class="cmt"># Private Timer</span>
LOAD = 0x4F587 (324,999)    <span class="cmt">// 325 MHz / 325,000 = 1 ms tick. Correct!</span>
CTRL = 0x7                  <span class="cmt">// Enabled + Auto-reload + IRQ. Correct!</span>
Counter decrementing...      <span class="cmt">// Timer is running!</span>

<span class="cmt"># GIC</span>
CPU_CTRL  = 0x3             <span class="cmt">// CPU interface enabled. Correct!</span>
PRI_MASK  = 0xF8            <span class="cmt">// Priority mask. Correct!</span>
DIST_CTRL = 0x3             <span class="cmt">// Distributor enabled. Correct!</span>
EN_SET0   = 0x2000FFFF      <span class="cmt">// IRQ 29 (timer) + SGIs enabled. Correct!</span>
</pre>

<p>
Every single peripheral register was configured exactly as expected. Timer
ticking at 1 ms, GIC routing interrupts, context switching happening.
But... no serial output.
</p>

<h4>The UART ID Problem</h4>

<p>
The UART0 status register showed <code>SR = 0x0A</code> (TX FIFO empty,
RX FIFO empty). UART appeared enabled (<code>CR = 0x114</code>) but nothing
was being transmitted. We verified the serial link was good by manually
writing to the TX FIFO via JTAG:
</p>

<pre>
> mww 0xE0000030 0x54    <span class="cmt"># 'T'</span>
> mww 0xE0000030 0x45    <span class="cmt"># 'E'</span>
> mww 0xE0000030 0x53    <span class="cmt"># 'S'</span>
> mww 0xE0000030 0x54    <span class="cmt"># 'T'</span>
</pre>

<p>
"TEST" appeared on the serial console instantly. The UART hardware was fine.
The serial cable was fine. Something in our code was writing to the
<em>wrong UART</em>.
</p>

<p>
And then it clicked. The threads app (and all STM32 apps) use
<code>hal::UartId::Usart1</code> as the "primary serial port." On STM32,
Usart1 maps to USART1 peripheral. But on the Zynq HAL, the
<code>uartBase()</code> function only recognized <code>UartId::Uart0</code>
and <code>UartId::Uart1</code>&mdash;it sent <code>Usart1</code> to the
<em>default case</em>, which returned the UART1 base address
(<code>0xE0001000</code>). Our app was dutifully transmitting to
UART1, which isn't connected to anything on the PYNQ-Z2.
</p>

<p>
The fix was two lines:
</p>

<pre>
<span class="cmt">// Uart.cpp: uartBase()</span>
<span class="kw">case</span> hal::UartId::Uart0:
<span class="kw">case</span> hal::UartId::Usart1:   <span class="cmt">// Map STM32 "primary serial" to Zynq UART0</span>
    <span class="kw">return</span> kUart0Base;

<span class="cmt">// Rcc.cpp: rccEnableUartClock()</span>
<span class="kw">case</span> UartId::Uart0:
<span class="kw">case</span> UartId::Usart1:        <span class="cmt">// Same mapping for clock enable</span>
    reg(kSlcrBase + kAperClkCtrl) |= (<span class="num">1U</span> &lt;&lt; kUart0ClkBit);
</pre>

<p>
Two lines. Hours of debugging for two lines. That's embedded development.
</p>

<h4>The L2 Cache Nightmare: Why JTAG Reload Stopped Working</h4>

<p>
With the UART fix in place, we rebuilt and tried to JTAG-load the new binary.
Nothing. No serial output. CPU halted somewhere unexpected.
</p>

<p>
Wait&mdash;this worked five minutes ago! What changed?
</p>

<p>
Here's the thing about JTAG loading on a cached system: when OpenOCD writes
our binary to DDR via the debug port, it writes to <strong>physical DRAM</strong>.
But the CPU has the <strong>L2 cache (PL310)</strong> sitting between it and
DRAM. If the L2 cache holds code from the <em>previous</em> binary, the CPU
will keep fetching that stale cached code even though DRAM now has the new
binary.
</p>

<p>
On the first load, there was no previous binary cached. It worked. On the
second load, the L2 cache was full of code from the first run. The CPU
fetched the old code from L2, completely ignoring the new binary in DRAM.
</p>

<div class="diagram">
  <span class="label">The L2 Cache Problem</span>

  JTAG Load #1 (cold boot, caches empty):
    OpenOCD writes binary to DRAM  -->  CPU fetches from DRAM  -->  WORKS

  JTAG Load #2 (warm reload, caches hot):
    OpenOCD writes NEW binary to DRAM
    But L2 still has OLD binary cached
    CPU fetches from L2  -->  executes OLD code  -->  BROKEN

  The fix requires invalidating L2 BEFORE the CPU fetches any code.
  But our boot code that invalidates L2 is ALSO cached in L2.
  <span class="label">Catch-22.</span>
</div>

<p>
We added L2 cache invalidation to Startup.s:
</p>

<pre>
<span class="cmt">// Disable L2 cache (PL310 controller)</span>
ldr     r0, =<span class="num">0xF8F02100</span>     <span class="cmt">// L2C-310 Control Register</span>
mov     r1, #<span class="num">0</span>
str     r1, [r0]            <span class="cmt">// Disable L2</span>
dsb

<span class="cmt">// Invalidate all L2 ways</span>
ldr     r0, =<span class="num">0xF8F0277C</span>     <span class="cmt">// Invalidate by Way register</span>
mov     r1, #<span class="num">0xFF</span>           <span class="cmt">// All 8 ways</span>
str     r1, [r0]
<span class="num">3</span>:  ldr     r2, [r0]        <span class="cmt">// Poll until complete</span>
    tst     r2, #<span class="num">0xFF</span>
    bne     <span class="num">3</span>b
dsb
</pre>

<p>
But this didn't help for JTAG reload, because the boot code itself was cached
in L2 from the previous run. The old version of Startup.s (without the L2
invalidation) was what the CPU actually executed. Classic chicken-and-egg.
</p>

<h4>The Solution: Cache Invalidation via JTAG</h4>

<p>
The answer was to invalidate the caches <em>from OpenOCD</em>, before the CPU
even starts. We wrote a TCL script that does the full dance:
</p>

<pre>
<span class="cmt"># pynq_jtag_load.tcl -- load binary with full cache invalidation</span>
proc jtag_load {elf_path} {
    init
    targets zynq.cpu0
    halt
    sleep 200

    <span class="cmt"># Disable L1 D-cache and I-cache via SCTLR</span>
    set sctlr [zynq.cpu0 arm mrc 15 0 1 0 0]
    set sctlr [expr {$sctlr & ~(1 &lt;&lt; 0)}]    <span class="cmt">;# MMU off</span>
    set sctlr [expr {$sctlr & ~(1 &lt;&lt; 2)}]    <span class="cmt">;# D-cache off</span>
    set sctlr [expr {$sctlr & ~(1 &lt;&lt; 12)}]   <span class="cmt">;# I-cache off</span>
    zynq.cpu0 arm mcr 15 0 1 0 0 $sctlr

    <span class="cmt"># Invalidate L1 I-cache</span>
    zynq.cpu0 arm mcr 15 0 7 5 0 0

    <span class="cmt"># Invalidate L1 D-cache (all 4 ways x 256 sets)</span>
    for {set way 0} {$way &lt; 4} {incr way} {
        for {set set_idx 0} {$set_idx &lt; 256} {incr set_idx} {
            set val [expr {($way &lt;&lt; 30) | ($set_idx &lt;&lt; 5)}]
            zynq.cpu0 arm mcr 15 0 7 6 2 $val
        }
    }

    <span class="cmt"># Disable L2 cache (PL310)</span>
    mww 0xF8F02100 0x00000000
    sleep 10

    <span class="cmt"># Invalidate all L2 ways</span>
    mww 0xF8F0277C 0x000000FF
    sleep 50

    <span class="cmt"># Invalidate TLBs</span>
    zynq.cpu0 arm mcr 15 0 8 7 0 0

    echo "&gt;&gt;&gt; Caches invalidated. Loading ELF..."
    load_image $elf_path
    echo "&gt;&gt;&gt; Resuming at 0x00100000..."
    resume 0x00100000
}
</pre>

<p>
The script halts the CPU, disables all caches and MMU via CP15 coprocessor
writes through the JTAG debug interface, then invalidates every L1 cache line
(iterating all 4 ways x 256 sets), disables and invalidates the L2 PL310,
flushes the TLBs, and <em>only then</em> loads the new binary and resumes.
</p>

<h4>Victory #2: JTAG Reload Works</h4>

<pre>
$ openocd -f pynq_load.cfg -f pynq_jtag_load.tcl \
    -c "jtag_load build/app/threads/threads.elf"

&gt;&gt;&gt; Caches invalidated. Loading ELF...
&gt;&gt;&gt; Resuming at 0x00100000...
</pre>

<p>
Serial console:
</p>

<pre>
ms-os kernel starting
tick 0
mem ok pool=8/8 heap=0/16376
tick 1
tick 2
tick 3
...
</pre>

<p>
The RTOS was running via JTAG reload. Timer ticking. Three threads switching.
Memory management operational. Pool allocations working. Heap working. Every
single component that took months to build on Cortex-M was now running on
Cortex-A9.
</p>

<p>
That moment&mdash;seeing <code>"ms-os kernel starting"</code> on the serial
console from a completely different processor architecture&mdash;was one of the
most satisfying moments of the entire project. Months of careful abstraction,
the Arch.h interface, the platform-separated HAL, the build system that
selects the right files&mdash;it all paid off in that instant.
</p>

<h4>Victory #3: Clean SD Card Boot</h4>

<p>
To confirm the system worked without JTAG cache tricks, we built a BOOT.BIN
(Xilinx boot image: FSBL + our ELF) and booted from SD card. The FSBL does
a clean PS initialization, loads our binary to DDR, and jumps to it. No
stale caches, no u-boot residue.
</p>

<pre>
<span class="cmt"># boot.bif -- Xilinx Boot Image Format descriptor</span>
the_ROM_image:
{
    [bootloader]/path/to/zynq_fsbl.elf
    /path/to/threads.elf
}
</pre>

<pre>
$ bootgen -image boot.bif -o BOOT.BIN -w
</pre>

<p>
Copied BOOT.BIN to SD card, inserted into PYNQ-Z2, powered on. The serial
console showed the full RTOS output. Clean boot. No JTAG needed.
</p>

<h4>The Remaining Battles</h4>

<p>
The RTOS was running, but not perfectly. Two issues remained: thread state
corruption and UART output garbling. What followed was one of the most
satisfying debugging sessions of the entire project.
</p>

<h4>The Hunt for the Register Ghost</h4>

<p>
<strong>Symptom 1:</strong> When running two threads (LED + UART), the UART
thread's tick counter showed bizarre behavior. Instead of counting 0, 1, 2,
3..., the serial output flooded with two alternating values:
<code>"tick 30"</code> and <code>"tick 1"</code>, repeating thousands of times
per second. The counter was stuck.
</p>

<p>
The first experiment was to comment out the memThread and add critical sections
(<code>enterCritical</code>/<code>exitCritical</code>) around the UART writes
in the uartThread. This eliminated the garbled output (confirming the
interleaving theory), but the counter corruption remained.
</p>

<p>
<strong>Initial hypothesis:</strong> A scheduler race condition specific to
Cortex-A9. On Cortex-M, PendSV runs at the <em>lowest</em> interrupt priority,
creating a natural deferred context switch. On Cortex-A9, the SGI fires at
priority 0xF0 while the timer runs at 0xA0 (higher). Could the timer ISR
fire between <code>exitCritical()</code> and <code>triggerContextSwitch()</code>?
</p>

<p>
We dug deep into <code>Kernel.cpp</code>, <code>Scheduler.cpp</code>,
<code>ContextSwitch.s</code>, and <code>Thread.cpp</code>, tracing every
path through <code>yield()</code> and <code>sleep()</code>. The scheduler
race was real but would cause missed or double switches&mdash;not counter
corruption. Something else was at work.
</p>

<p>
<strong>The pivotal experiment:</strong> We switched the threads from
yield-based timing to <code>sleep()</code>-based timing:
</p>

<pre>
<span class="kw">void</span> <span class="fn">uartThread</span>(<span class="kw">void</span> *)
{
    std::uint32_t counter = <span class="num">0</span>;
    <span class="kw">while</span> (<span class="kw">true</span>)
    {
        <span class="cmt">// ... print counter ...</span>
        ++counter;
        kernel::<span class="fn">sleep</span>(<span class="num">1000</span>);
    }
}
</pre>

<p>
The output was devastating:
</p>

<pre>
tick 4176478465
tick 4176478465
tick 4176478465
tick 4176478465
</pre>

<p>
The counter was stuck at <strong>4,176,478,465</strong>. In hex:
<code>0xF8F00101</code>. That number looked familiar...
</p>

<p>
<code>0xF8F00100</code> is the <strong>GIC CPU interface base address</strong>.
And <code>0xF8F00101</code> is that value plus one&mdash;exactly what
<code>++counter</code> would produce if <code>counter</code> had been
overwritten with <code>0xF8F00100</code>.
</p>

<div class="highlight">
<strong>Smoking gun:</strong> <code>0xF8F00101 = GIC_CPU_BASE + 1</code>.
The compiler placed the thread's <code>counter</code> variable in register
<code>r4</code>. Something was writing the GIC base address into
<code>r4</code> during context switches.
</div>

<h4>Root Cause: Callee-Saved Register Clobbering</h4>

<p>
The bug was in <code>ContextSwitch.s</code>, the Cortex-A9 IRQ handler.
Here is the original code (simplified):
</p>

<pre>
<span class="fn">IRQ_Handler</span>:
    sub     lr, lr, #<span class="num">4</span>
    srsdb   sp!, #<span class="num">0x1F</span>
    cps     #<span class="num">0x1F</span>
    push    {r0-r3, r12, lr}

    <span class="cmt">/* Read GIC ICCIAR to get interrupt ID */</span>
    ldr     <span class="kw">r4</span>, =GIC_CPU_BASE       <span class="cmt">/* BUG: clobbers r4! */</span>
    ldr     <span class="kw">r5</span>, [<span class="kw">r4</span>, #ICCIAR_OFFSET]  <span class="cmt">/* BUG: clobbers r5! */</span>
    ...
    <span class="cmt">/* Context switch */</span>
    push    {r4-r11}     <span class="cmt">/* Saves WRONG r4/r5! */</span>
    str     sp, [r2, #<span class="num">0</span>]
</pre>

<p>
The IRQ handler used <code>r4</code> and <code>r5</code> for GIC register
access <em>before</em> the context switch saved them with
<code>push {r4-r11}</code>. On entry, <code>r0-r3</code> are saved, but
<code>r4-r11</code> belong to the <strong>interrupted thread</strong>.
They are callee-saved registers&mdash;the thread expects their values to be
preserved across function calls and interrupts.
</p>

<p>
By loading <code>GIC_CPU_BASE</code> into <code>r4</code>, the handler
destroyed whatever value the thread had in <code>r4</code>. When the context
switch later did <code>push {r4-r11}</code> to "save" the thread's state,
it saved the <em>handler's</em> <code>r4</code> (= <code>0xF8F00100</code>)
instead of the thread's <code>r4</code> (= <code>counter</code>). When the
thread was restored, its local variable <code>counter</code> contained the
GIC base address.
</p>

<p>
The reason <code>r4</code> and <code>r5</code> were used is that they are
callee-saved: their values survive across the C function calls
(<code>bl PrivateTimer_Handler</code>, <code>bl SysTick_Handler</code>) that
the IRQ handler makes. Using <code>r0-r3</code> for the GIC address would
lose them across those calls. The original author needed registers that
persisted&mdash;but those same registers belonged to the interrupted thread.
</p>

<div class="diagram">
<span class="label">BEFORE (buggy):</span>

Thread running with counter=42 in r4
    |
    v
IRQ fires -> hardware saves LR_irq, SPSR_irq
    |
    v
Handler:  push {r0-r3, r12, lr}   -- saves caller-saved
          ldr  r4, =0xF8F00100    -- OVERWRITES thread's r4 (was 42)
          ldr  r5, [r4, #0x0C]    -- OVERWRITES thread's r5
          ...bl PrivateTimer_Handler...
          ...bl SysTick_Handler...
    |
    v
Context switch:
          push {r4-r11}           -- saves r4=0xF8F00100, NOT 42!
          str  sp, [outgoing]
          ldr  sp, [incoming]
          pop  {r4-r11}           -- loads incoming thread
    |
    v
Later, original thread restored:
          pop  {r4-r11}           -- r4 = 0xF8F00100 (was 42!)
          counter is now 0xF8F00100
          ++counter => 0xF8F00101 = 4176478465
</div>

<h4>The Fix</h4>

<p>
The fix is simple but required understanding the constraint: between the
initial <code>push {r0-r3, r12, lr}</code> and the context switch's
<code>push {r4-r11}</code>, only <code>r0-r3</code> (already saved) and
the stack may be used. The ICCIAR value that must survive across C calls
goes on the stack instead:
</p>

<pre>
<span class="fn">IRQ_Handler</span>:
    sub     lr, lr, #<span class="num">4</span>
    srsdb   sp!, #<span class="num">0x1F</span>
    cps     #<span class="num">0x1F</span>
    push    {r0-r3, r12, lr}

    <span class="cmt">/* CRITICAL: Do NOT use r4-r11 before the context switch!
     * Those registers belong to the interrupted thread. */</span>

    ldr     r0, =GIC_CPU_BASE
    ldr     r1, [r0, #ICCIAR_OFFSET]
    push    {r1}                <span class="cmt">/* Save ICCIAR on stack */</span>

    ubfx    r0, r1, #<span class="num">0</span>, #<span class="num">10</span>   <span class="cmt">/* Extract IRQ ID */</span>
    cmp     r0, #PRIVATE_TIMER_IRQ
    beq     .Ltimer_irq
    ...

.Lirq_eoi:
    pop     {r1}                <span class="cmt">/* Restore ICCIAR from stack */</span>
    ldr     r0, =GIC_CPU_BASE
    str     r1, [r0, #ICCEOIR_OFFSET]

    <span class="cmt">/* Now r4-r11 are still the interrupted thread's values */</span>
    push    {r4-r11}            <span class="cmt">/* Correct! */</span>
    ...
</pre>

<p>
After the fix, serial output was perfect:
</p>

<pre>
$ python3 -c "import serial; s = serial.Serial('/dev/ttyUSB1', 115200, timeout=15); ..."
ms-os kernel starting
tick 0
tick 1
tick 2
tick 3
tick 4
mem ok pool=8/8 heap=0/16376
tick 5
tick 6
tick 7
tick 8
tick 9
mem ok pool=8/8 heap=0/16376
tick 10
...
</pre>

<p>
Monotonically incrementing tick counter. Memory tests passing every 5 seconds.
No garbled output. All three threads running correctly.
</p>

<h4>Thread-Safe UART</h4>

<p>
With the context switch fixed, the UART thread safety was straightforward.
Each platform's <code>uartWrite()</code> now saves the interrupt state,
disables IRQs for the duration of the write, and restores the previous state:
</p>

<pre>
<span class="cmt">/* Zynq (Cortex-A9): save/restore CPSR */</span>
<span class="kw">void</span> <span class="fn">uartWrite</span>(UartId id, <span class="kw">const</span> <span class="kw">char</span> *data, std::size_t length)
{
    std::uint32_t saved = <span class="fn">disableIrq</span>();  <span class="cmt">// mrs cpsr + cpsid i</span>
    <span class="kw">for</span> (std::size_t i = <span class="num">0</span>; i &lt; length; ++i)
        <span class="fn">uartPutChar</span>(id, data[i]);
    <span class="fn">restoreIrq</span>(saved);                   <span class="cmt">// msr cpsr_c</span>
}

<span class="cmt">/* STM32 (Cortex-M): save/restore PRIMASK */</span>
<span class="kw">void</span> <span class="fn">uartWrite</span>(UartId id, <span class="kw">const</span> <span class="kw">char</span> *data, std::size_t length)
{
    std::uint32_t saved = <span class="fn">disableIrq</span>();  <span class="cmt">// mrs primask + cpsid i</span>
    <span class="kw">for</span> (std::size_t i = <span class="num">0</span>; i &lt; length; ++i)
        <span class="fn">uartPutChar</span>(id, data[i]);
    <span class="fn">restoreIrq</span>(saved);                   <span class="cmt">// msr primask</span>
}
</pre>

<p>
This makes each <code>uartWriteString()</code> call atomic. The application
still uses critical sections around multi-call sequences (e.g.,
<code>"tick " + number + "\r\n"</code>) to prevent interleaving between
calls, but the HAL itself is now safe for concurrent access.
</p>

<div class="lesson">
<strong>Lesson 5:</strong> On Cortex-A9, the IRQ handler runs in the
interrupted thread's register context. Registers <code>r4-r11</code> are
<em>not free scratch space</em>&mdash;they belong to the interrupted thread
and must not be touched between entry and the context switch save. On
Cortex-M, PendSV has the same constraint, but the hardware exception frame
automatically saves <code>r0-r3, r12, LR, PC, xPSR</code>. On Cortex-A9,
you must be even more disciplined because the save is entirely manual.
</div>

<div class="lesson">
<strong>Lesson 5a:</strong> When a variable takes on an impossible value,
convert it to hex. <code>4176478465</code> means nothing.
<code>0xF8F00101</code> is immediately recognizable as a hardware register
address (GIC CPU interface + 1). The hex representation turned a mystery
into a smoking gun.
</div>

<h3>The Debugging Lessons</h3>

<p>
The PYNQ-Z2 bringup taught us more about ARM architecture in a few sessions
than months of reading reference manuals. Every bug was a lesson:
</p>

<div class="lesson">
<strong>Lesson 1:</strong> Linux leaves extensive hardware state. The GIC has
pending timer interrupts that fire <em>before your first instruction executes</em>.
You must disable the GIC and clear all pending IRQs via OpenOCD before resuming.
</div>

<div class="lesson">
<strong>Lesson 2:</strong> CPU1's MMU interferes with debug memory access.
Even with CPU0's MMU disabled, OpenOCD routes some reads through CPU1.
Disable MMU on <em>both</em> CPUs before any bare-metal work.
</div>

<div class="lesson">
<strong>Lesson 3:</strong> Always cross-reference register definitions against
the TRM. We spent hours debugging silent UART output because our Control
Register bit definitions were wrong&mdash;we were asserting STARTBRK
(forcing TXD permanently LOW) instead of resetting the TX FIFO.
</div>

<div class="lesson">
<strong>Lesson 4:</strong> WFE on Cortex-A9 can gate the debug clock domain,
making the CPU unreachable via JTAG. Use infinite <code>b .</code> loops
instead of WFE during early bringup.
</div>

<div class="lesson">
<strong>Lesson 6:</strong> JTAG reads bypass the CPU's data cache. If your
code uses write-back caching (which it should, for performance), variables
read via JTAG will show stale DRAM values, not the current values in the
D-cache. Don't trust JTAG memory reads for variables that are actively being
updated by the CPU. Use direct register reads (via CP15 MCR/MRC through
OpenOCD) instead.
</div>

<div class="lesson">
<strong>Lesson 7:</strong> L2 cache invalidation is mandatory for JTAG binary
reload, but the boot code that does the invalidation is <em>itself</em>
cached from the previous run. You must invalidate from outside the CPU
(via the JTAG debug interface) before loading new code.
</div>

<div class="lesson">
<strong>Lesson 8:</strong> When bringing up a new architecture, verify
each subsystem independently. Write "TEST" to the UART FIFO via JTAG
to confirm the serial link works before debugging your UART driver code.
Check GIC, timer, and MMU registers via JTAG independently. Don't assume
the whole system is broken just because you see no output&mdash;isolate
the problem.
</div>

<h3>Where We Stand</h3>

<p>
The PYNQ-Z2 port is fully operational. The r4/r5 register clobbering bug
is fixed, UART output is thread-safe at the HAL level, and all three
threads run correctly on Cortex-A9. The full RTOS&mdash;scheduler, context
switching, memory management, crash dumps&mdash;works on all three hardware
targets. The architecture abstraction delivers on its promise: the same
kernel source code, the same application code, builds and runs on Cortex-M3,
Cortex-M4, and Cortex-A9 by selecting the target at build time.
</p>

<div class="highlight">
<strong>Status after Phase 4:</strong> ms-os runs on <strong>three hardware
targets</strong> spanning two ARM architecture families (ARMv7-M and ARMv7-A),
with <strong>136 host unit tests</strong>, three cross-compiled applications,
thread-safe UART, and a fully operational JTAG development workflow. All bugs
resolved. Binary size for the full RTOS with three threads:
<strong>10,740 bytes</strong> of code on Cortex-A9.
</div>

<!-- ============================================================ -->
<!--                      EPILOGUE                                -->
<!-- ============================================================ -->
<h2 class="chapter">
  <span class="ch-num">Epilogue</span>
  The Road Ahead
</h2>

<div class="epigraph">
  "The best way to predict the future is to implement it."
  <div class="attribution">&mdash; Alan Kay</div>
</div>

<p>
As of February 2026, ms-os runs on three hardware targets spanning two ARM
architecture families, with 136 passing unit tests. The kernel schedules
8 threads across 32 priority levels, protects memory with the MPU, allocates
from both fixed-size pools and a coalescing heap, prints detailed crash dumps
when things go wrong, context-switches correctly on both Cortex-M and
Cortex-A9, and outputs thread-safe serial on all platforms.
</p>

<p>
The PYNQ-Z2 bringup proved that the architecture was sound&mdash;and the
debugging proved it was fragile in the right ways. The r4/r5 register
clobbering bug could only manifest on real hardware under real preemption.
It taught us that callee-saved registers in an IRQ handler are not free
scratch space. Code written for a 120 MHz Cortex-M3 with 128 KB of SRAM
runs on a 650 MHz Cortex-A9 with 512 MB of DDR3. The same scheduler, the
same mutex, the same heap allocator&mdash;just a different set of assembly
files and HAL implementations selected at build time. That portability
didn't happen by accident. It was the result of disciplined abstraction
from day one.
</p>

<p>
But the journey is far from over. The roadmap includes:
</p>

<ul>
  <li><strong>IPC message passing</strong> &mdash; Microkernel inter-process
      communication using the ms-ipc library as inspiration</li>
  <li><strong>Unprivileged threads</strong> &mdash; Run user threads in
      unprivileged mode with MPU/MMU enforcement</li>
  <li><strong>User-space drivers</strong> &mdash; Move device drivers out
      of the kernel into user-space services</li>
  <li><strong>SMP support</strong> &mdash; Utilize the PYNQ-Z2's second
      Cortex-A9 core</li>
  <li><strong>Device tree</strong> &mdash; YAML-based hardware description
      for runtime configuration</li>
  <li><strong>Custom bootloader</strong> &mdash; Replace u-boot with our own,
      using <code>ps7_init</code> for standalone Zynq PS initialization</li>
</ul>

<p>
Each phase builds on the last. Each line of assembly teaches something that
no textbook can. Every bug is a lesson&mdash;and every fix is a celebration.
Somewhere in the intersection of silicon and software, an operating system
continues to grow.
</p>

<!-- ============================================================ -->
<!--                    APPENDIX A                                -->
<!-- ============================================================ -->
<h2 class="chapter">
  <span class="ch-num">Appendix A</span>
  Hardware Targets
</h2>

<table>
<tr>
  <th>Board</th>
  <th>SoC</th>
  <th>Core</th>
  <th>Clock</th>
  <th>Flash</th>
  <th>RAM</th>
</tr>
<tr>
  <td>Custom (F207)</td>
  <td>STM32F207ZGT6</td>
  <td>Cortex-M3</td>
  <td>120 MHz</td>
  <td>1 MB</td>
  <td>128 KB SRAM</td>
</tr>
<tr>
  <td>Custom (F407)</td>
  <td>STM32F407ZGT6</td>
  <td>Cortex-M4</td>
  <td>168 MHz</td>
  <td>1 MB</td>
  <td>128 KB + 64 KB CCM</td>
</tr>
<tr>
  <td>PYNQ-Z2</td>
  <td>Zynq-7020</td>
  <td>Dual Cortex-A9</td>
  <td>650 MHz</td>
  <td>(SD card)</td>
  <td>512 MB DDR3</td>
</tr>
</table>

<h3>Build Sizes (Threads App)</h3>

<table>
<tr><th>Target</th><th>.text</th><th>.data</th><th>.bss</th><th>Total</th></tr>
<tr><td>STM32F207</td><td>8,240 B</td><td>12 B</td><td>35,840 B</td><td>44,092 B</td></tr>
<tr><td>STM32F407</td><td>8,360 B</td><td>12 B</td><td>35,840 B</td><td>44,212 B</td></tr>
<tr><td>PYNQ-Z2</td><td>10,740 B</td><td>8 B</td><td>54,272 B</td><td>65,020 B</td></tr>
</table>

<!-- ============================================================ -->
<!--                    APPENDIX B                                -->
<!-- ============================================================ -->
<h2 class="chapter">
  <span class="ch-num">Appendix B</span>
  Project Timeline
</h2>

<div class="timeline">
  <div class="event">
    <div class="event-title">Phase 0 &mdash; Foundation</div>
    Toolchain, HAL (GPIO, UART, RCC), startup assembly, dual build system,
    link-time mock testing. First LED blink and serial output on F207.
  </div>
  <div class="event">
    <div class="event-title">Phase 1 &mdash; Kernel Core</div>
    Thread creation, PendSV context switch, SVC first-thread launch,
    SysTick tick handler, three-layer crash dump system. Hardware verified
    on F207 and F407.
  </div>
  <div class="event">
    <div class="event-title">Phase 2 &mdash; Scheduling</div>
    32-priority bitmap scheduler, round-robin time slicing, mutex with
    mandatory priority inheritance, counting semaphore, sleep/yield,
    wait queues. 136 host tests passing.
  </div>
  <div class="event">
    <div class="event-title">Phase 3 &mdash; Memory Management</div>
    Block pool (O(1) fixed-size), heap (first-fit + coalescing), MPU
    configuration (6 regions, per-thread stack protection), C++ operator
    new/delete overloads.
  </div>
  <div class="event">
    <div class="event-title">Phase 4A &mdash; PYNQ-Z2 Bringup</div>
    ARM mode startup, DDR linker script, Zynq UART/RCC/GPIO HAL,
    OpenOCD JTAG configuration. Cross-compilation for Cortex-A9.
  </div>
  <div class="event">
    <div class="event-title">Phase 4B &mdash; Cortex-A9 RTOS Port</div>
    Arch.h abstraction, GIC/private timer drivers, IRQ-based context
    switch with SRS/RFE, fault handlers, crash dump for A9.
  </div>
  <div class="event">
    <div class="event-title">Phase 4 Hardware Bringup &mdash; The Debugging Saga</div>
    Alignment fault (DFSR=0x801) diagnosed as MMU-disabled Strongly Ordered
    memory. Built flat 1:1 MMU with 16 KB L1 translation table. Fixed UART
    ID mapping (Usart1 to Uart0). Discovered L2 cache stale code problem
    on JTAG reload; solved with OpenOCD TCL cache invalidation script.
    Full RTOS verified running on PYNQ-Z2 via both JTAG and SD card boot.
  </div>
  <div class="event">
    <div class="event-title">Phase 4 &mdash; The Register Ghost</div>
    Identified and fixed r4/r5 callee-saved register clobbering in the
    Cortex-A9 IRQ handler. The GIC base address (0xF8F00100) was being
    written to r4 before the context switch saved it, destroying interrupted
    threads' local variables. Added thread-safe UART at the HAL level
    with interrupt save/restore guards. All three threads verified correct
    on PYNQ-Z2 hardware.
  </div>
</div>

<div style="text-align: center; margin-top: 4cm; color: #999; font-style: italic;">
  &mdash; End &mdash;
</div>

</body>
</html>
